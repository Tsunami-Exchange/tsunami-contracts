  {-# STDLIB_VERSION 6 #-}
  {-# CONTENT_TYPE DAPP #-}
  {-# SCRIPT_TYPE ACCOUNT #-}

  ##### Key constants #####
  let k_totalFeesInPeriod = "k_totalFeesInPeriod"
  let k_totalAssetFeesInPeriod = "k_totalAssetFeesInPeriod"
  let k_traderFeesInPeriod = "k_traderFeesInPeriod"
  let k_lastNotional = "k_lastNotional"
  let k_totalScoreInPeriod = "k_totalScoreInPeriod"
  let k_traderScoreInPeriod = "k_traderScoreInPeriod"
  let k_traderAverageNotionalInPeriod = "k_traderAverageNotionalInPeriod"
  let k_ammRewardRate = "k_ammRewardRate"
  let k_assetMaxAmountPerPeriod = "k_assetMaxAmountPerPeriod"
  let k_rewardAssetIds = "k_rewardAssetIds"
  let k_amms = "k_amms"
  let k_claimedAssetAndPeriod = "k_claimedAssetAndPeriod"
  let k_oracleAddress = "k_oracleAddress"
  let k_oraclePrice = "price"
  let k_totalClaimedForTraderAndAsset = "k_totalClaimedForTraderAndAsset"
  
  # Initialization status
  let k_initialized = "k_initialized"

  # Coordinator
  let k_coordinatorAddress = "k_coordinatorAddress"
  let k_governance_asset = "k_gov_asset"
  let k_quote_asset = "k_quote_asset" 
  let k_admin_public_key = "k_admin_public_key"
  let k_admin_address = "k_admin_address" 
  let k_amm = "k_amm"                               

  ##### Core constants #####

  let DECIMAL_UNIT = 1 * (10 * 10 * 10 * 10 * 10 * 10 * 10 * 10) # 10 ** 8
  let A = 70000000 # 0.7 * 10**8
  let MS_IN_WEEK = 1000 * 604800

  ##### Helper functions #####
  func listToStr(_list: List[String]) = {
    func _join(accumulator: String, val: String) = accumulator + val + ","
    let newListStr = FOLD<100>(_list, "", _join)
    let newListStrU = newListStr.dropRight(1)
    let newListStrR = if (newListStrU.take(1) == ",") then newListStrU.drop(1) else newListStrU
    newListStrR
  }

  func strToList(_str: String) = if (_str == "") then [] else _str.split(",")

  func divd(_x: Int, _y: Int) = fraction(_x, DECIMAL_UNIT, _y, HALFEVEN)
  func muld(_x: Int, _y: Int) = fraction(_x, _y, DECIMAL_UNIT, HALFEVEN)
  func powd(_x: Int, _y: Int) = pow(_x, 8, _y, 8, 8, HALFEVEN)
  func abs(_x: Int) = if (_x > 0) then _x else -_x
  func minv(_x: Int, _y: Int) = if (_x > _y) then _y else _x

  func toCompositeKey(_key: String, _address: String) = _key + "_" + _address

  ##### Coordinator constants #####
  func coordinator() = addressFromString(this.getStringValue(k_coordinatorAddress)).valueOrErrorMessage("Coordinator not set")
  func adminPublicKey() = fromBase58String(coordinator().getStringValue(k_admin_public_key))
  func adminAddress() = addressFromString(coordinator().getStringValue(k_admin_address))
  func isWhitelist(_address: String) = getBoolean(coordinator(), k_amm.toCompositeKey(_address)).valueOrElse(false)

  ##### Accessor functions #####
  func int(k: String) = this.getInteger(k).valueOrErrorMessage("no value for " + k)
  func int0(k: String) = this.getInteger(k).valueOrElse(0)

  func initialized() = this.getBoolean(k_initialized).valueOrElse(false)

  func getRewardAssetIds() = {
    strToList(this.getString(k_rewardAssetIds).valueOrElse(""))
  }
  
  # Helper for testing
  let TIME = lastBlock.timestamp

  ##### Key functions #####
  func getTraderFeesInPeriodKey(_amm: String, _trader: String, _weekId: Int) = {
    k_traderFeesInPeriod + "_" + _amm + "_" + _trader + "_" + _weekId.toString()
  }

  func getTotalAmmFeesInPeriodKey(_amm: String, _weekId: Int) = {
    k_totalFeesInPeriod + "_" + _amm + "_" + _weekId.toString()
  }

  func getTotalAssetFeesInPeriodKey(_assetId: String, _weekId: Int) = {
    k_totalAssetFeesInPeriod + "_" + _assetId + "_" + _weekId.toString()
  }

  func getLastNotionalKey(_amm: String, _trader: String) = {
    k_lastNotional + "_" + _amm + "_" + _trader
  }

  func getTraderScoreInPeriodKey(_amm: String, _trader: String, _weekId: Int) = {
    k_traderScoreInPeriod + "_" + _amm + "_" + _trader + "_" + _weekId.toString()
  }

  func getTotalScoreInPeriodKey(_amm: String, _weekId: Int) = {
    k_totalScoreInPeriod + "_" + _amm + "_" + _weekId.toString()
  }

  func getTraderAverageNotionalInPeriodKey(_amm: String, _trader: String, _weekId: Int) = {
    k_traderAverageNotionalInPeriod + "_" + _amm + "_" + _trader + "_" + _weekId.toString()
  }

  func getAmmRewardRateKey(_amm: String, _assetId: String) = {
    k_ammRewardRate + "_" + _amm + "_" + _assetId
  }

  func getAssetMaxAmountPerPeriodKey(_assetId: String) = {
    k_assetMaxAmountPerPeriod + "_" + _assetId
  }

  func getClaimedTraderAssetPeriodKey(_trader: String, _assetId: String, _period: Int) = {
    k_claimedAssetAndPeriod + "_" + _trader + "_" + _assetId + "_" + _period.toString()
  }

  func getOraclePriceKey(_assetId: String, _period: Int) = {
    k_oraclePrice + "_" + _period.toString() + "_" + _assetId
  }

  func getTotalClaimedForTraderAndAssetKey(_trader: String, _assetId: String) = {
    k_totalClaimedForTraderAndAsset + "_" + _trader + "_" + _assetId
  }

  ##### View functions #####
  func usdnToDecimals(_amount: Int) = _amount * 100

  func getWeekStart(_weekId: Int) = _weekId * MS_IN_WEEK

  func getWeekEnd(_weekId: Int) = (_weekId + 1) * MS_IN_WEEK

  func getWeekId(_ts: Int) = _ts / MS_IN_WEEK

  func getFeesInPeriod(_amm: String, _trader: String, _weekId: Int) = {
    let key = getTraderFeesInPeriodKey(_amm, _trader, _weekId)
    this.getInteger(key).valueOrElse(0)
  }

  func getTotalFeesInPeriod(_amm: String, _weekId: Int) = {
    let key = getTotalAmmFeesInPeriodKey(_amm, _weekId)
    this.getInteger(key).valueOrElse(0)
  }

  func getTotalAssetFeesInPeriod(_assetId: String, _weekId: Int) = {
    let key = getTotalAssetFeesInPeriodKey(_assetId, _weekId)
    this.getInteger(key).valueOrElse(0)
  }

  func getLastNotional(_amm: String, _trader: String) = {
    let key = getLastNotionalKey(_amm, _trader)
    this.getInteger(key).valueOrElse(0)
  }

  func getTraderScoreInPeriod(_amm: String, _trader: String, _weekId: Int) = {
    let key = getTraderScoreInPeriodKey(_amm, _trader, _weekId)
    this.getInteger(key).valueOrElse(0)
  } 

  func getTotalScoreInPeriod(_amm: String, _weekId: Int) = {
    let key = getTotalScoreInPeriodKey(_amm, _weekId)
    this.getInteger(key).valueOrElse(0)
  }

  func getAmms() = {
    strToList(this.getString(k_amms).valueOrElse(""))
  }

  func getAmmRewardRate(_amm: String, _assetId: String) = {
    let key = getAmmRewardRateKey(_amm, _assetId)
    this.getInteger(key).valueOrElse(0)
  }

  func getAssetMaxAmountPerPeriod(_assetId: String) = {
    let key = getAssetMaxAmountPerPeriodKey(_assetId)
    this.getInteger(key).valueOrElse(0)
  }

  func getTotalClaimedForTraderAndAsset(_trader: String, _assetId: String) = {
    let key = getTotalClaimedForTraderAndAssetKey(_trader, _assetId)
    this.getInteger(key).valueOrElse(0)
  }

  func getRewardAssetPrice(_assetId: String, _weekId: Int) = {
    let oracleAddressStr = this.getString(k_oracleAddress).valueOrErrorMessage("Oracle not set")
    let oracleAddress = addressFromString(oracleAddressStr).valueOrErrorMessage("Invalid oracle address")
    let priceKey = getOraclePriceKey(_assetId, _weekId)

    oracleAddress.getInteger(priceKey).valueOrErrorMessage("No oracle price for asset " + _assetId + " period " + _weekId.toString()).usdnToDecimals()
  }

  func getMaxAmountOfAssetToDistribute(_amm: String, _assetId: String, _weekId: Int) = {
    let totalFeesInPeriod = getTotalFeesInPeriod(_amm, _weekId)
    let totalAssetFeesInPeriod = getTotalAssetFeesInPeriod(_assetId, _weekId)
    let maxAmountOfAsset = getAssetMaxAmountPerPeriod(_assetId)
    let maxAmountOfAssetToDistribute = totalFeesInPeriod.divd(totalAssetFeesInPeriod).muld(maxAmountOfAsset)
    maxAmountOfAssetToDistribute
  }

  func rewardForTraderInAssetInPeriod(_amm: String, _trader: String, _assetId: String, _weekId: Int) = {
    let rewardAssetRate = getAmmRewardRate(_amm, _assetId)
    if (rewardAssetRate == 0) then {
      0
    } else {
      let totalFeesInPeriod = getTotalFeesInPeriod(_amm, _weekId)
      let rewardAssetPrice = getRewardAssetPrice(_assetId, _weekId)
      let maxAmountOfAssetToDistribute = getMaxAmountOfAssetToDistribute(_amm, _assetId, _weekId)

      let traderScore = getTraderScoreInPeriod(_amm, _trader, _weekId)
      let totalTraderScore = getTotalScoreInPeriod(_amm, _weekId)

      if (totalTraderScore == 0) then {
        0
      } else {
        let totalAssetToDistribute = totalFeesInPeriod.muld(rewardAssetRate).divd(rewardAssetPrice)
        let actualTotalAssetToDistribute = minv(totalAssetToDistribute, maxAmountOfAssetToDistribute)
        let traderShareInRewards = actualTotalAssetToDistribute.muld(traderScore).divd(totalTraderScore)

        traderShareInRewards
      }
    }
  }

  func totalRewardForTraderInAssetInPeriod(_trader: String, _assetId: String, _weekId: Int) = {
    let amms = getAmms()
    func compute(_acc: Int, _amm: String) = _acc + rewardForTraderInAssetInPeriod(_amm, _trader, _assetId, _weekId)
    FOLD<20>(amms, 0, compute) # Max 20 AMM's
  }

  func totalRewardForTraderInAsset(_trader: String, _assetId: String, _periods: List[Int]) = {
    func compute(_acc: Int, _weekId: Int) = _acc + totalRewardForTraderInAssetInPeriod(_trader, _assetId, _weekId)
    FOLD<14>(_periods, 0, compute) # Max 14 Periods
  }

  func getTraderAverageNotionalInPeriod(_amm: String, _trader: String, _weekId: Int, _defaultValue: Int) = {
    let key = getTraderAverageNotionalInPeriodKey(_amm, _trader, _weekId)
    this.getInteger(key).valueOrElse(_defaultValue)
  }

  func isClaimed(_trader: String, _assetId: String, _period: Int) = {
    let key = getClaimedTraderAssetPeriodKey(_trader, _assetId, _period)
    this.getBoolean(key).valueOrElse(false)
  }

  func claimAllRewardForPeriodForTrader(_trader: String, _assetId: String, _periods: String) = {
    let periods = strToList(_periods)

    # Filter out unique periods that are not claimed
    func checkAndFilterFn(_acc: List[Int], _next: String) = {
      let period = _next.parseInt().valueOrErrorMessage("Invalid period: " + _next)
      if (
        _acc.containsElement(period)
        || isClaimed(_trader, _assetId, period)
      ) then _acc else _acc :+ period
    }
    let validPeriods = FOLD<16>(periods, [], checkAndFilterFn)
    
    func markPeriodAsDoneFn(_acc: List[BooleanEntry], _period: Int) = {
      _acc :+ BooleanEntry(
        getClaimedTraderAssetPeriodKey(_trader, _assetId, _period), 
        true
      )
    }

    let markPeriodsAsClaimed = FOLD<16>(validPeriods, [], markPeriodAsDoneFn)

    let amount = totalRewardForTraderInAsset(_trader, _assetId, validPeriods)

    (
      amount,
      [
        ScriptTransfer(
          addressFromStringValue(_trader),
          amount,
          fromBase58String(_assetId)
        ),
        IntegerEntry(
          getTotalClaimedForTraderAndAssetKey(_trader, _assetId),
          getTotalClaimedForTraderAndAsset(_trader, _assetId) + amount
        )
      ] ++ markPeriodsAsClaimed
    )
  }

  ##### Update functions #####
  func updateAmmFees(_amm: String, _trader: String, _weekId: Int, _actualFee: Int) = {
    let traderFeesKey = getTraderFeesInPeriodKey(_amm, _trader, _weekId)
    let totalFeesKey = getTotalAmmFeesInPeriodKey(_amm, _weekId)
    let rewardAssets = getRewardAssetIds()
    
    let feesInPeriod = getFeesInPeriod(_amm, _trader, _weekId)
    let totalFeesInPeriod = getTotalFeesInPeriod(_amm, _weekId)
    let newFeesInPeriod = feesInPeriod + _actualFee
    let newTotalFeesInPeriod = totalFeesInPeriod + _actualFee

    # Filter rewards for this AMM
    #
    func doHandleRewardAssetId(_acc: List[IntegerEntry], _assetId: String) = {
      let key = getAmmRewardRateKey(_amm, _assetId)
      if (this.getInteger(key).valueOrElse(0) > 0) then {
        let totalAssetFeesKey = getTotalAssetFeesInPeriodKey(_assetId, _weekId)
        _acc :+ IntegerEntry(
          totalAssetFeesKey,
          getTotalAssetFeesInPeriod(_assetId, _weekId) + _actualFee
        )
      } else {
        _acc
      }
    }

    let updateAssetFees = FOLD<10>(rewardAssets, [], doHandleRewardAssetId)

    [
      IntegerEntry(traderFeesKey, newFeesInPeriod),
      IntegerEntry(totalFeesKey, newTotalFeesInPeriod)
    ]
    ++
    updateAssetFees
  }

  func updateAmmData(
    _amm: String, 
    _trader: String,
    _weekId: Int, 
    _traderAverage: Int, 
    _traderLastNotional: Int, 
    _traderScore: Int, 
    _totalScore: Int
  ) = {
    let totalScoreInPeriodKey = getTotalScoreInPeriodKey(_amm, _weekId)
    let traderScoreInPeriodKey = getTraderScoreInPeriodKey(_amm, _trader, _weekId)
    let lastNotionalKey = getLastNotionalKey(_amm, _trader)
    let traderAverageNotionalInPeriodKey = getTraderAverageNotionalInPeriodKey(_amm, _trader, _weekId)

    [
      IntegerEntry(totalScoreInPeriodKey, _totalScore),
      IntegerEntry(traderScoreInPeriodKey, _traderScore),
      IntegerEntry(lastNotionalKey, _traderLastNotional),
      IntegerEntry(traderAverageNotionalInPeriodKey, _traderAverage)
    ]
  }

  ##### Callable functions #####

  @Callable(i)
  func initialize(
    _coordinator: String,
    _oracle: String
  ) = {
    if (initialized()) then {
      throw("Already initialized")
    } else {
      [
        StringEntry(k_coordinatorAddress, _coordinator),
        StringEntry(k_oracleAddress, _oracle),
        BooleanEntry(k_initialized, true)
      ]
    }
  }

  @Callable(i)
  func setOracleAddress(
    _oracle: String
  ) = {
    if (!initialized()
        || i.caller != adminAddress()
    ) then {
      throw("Invalid setOracleAddress parameters")
    } else {
      [
        StringEntry(k_oracleAddress, _oracle)
      ]
    }
  }

  @Callable(i)
  func view_getPeriod() = {
      let weekId = getWeekId(TIME)
      let weekStart = getWeekStart(weekId)
      let weekEnd = getWeekEnd(weekId)
      throw(weekStart.toString() + "," + weekEnd.toString() + "," + TIME.toString())
  }

  @Callable(i)
  func view_getMaxAmountOfAssetToDistribute(_amm: String, _assetId: String, _weekId: Int) = {
    throw(getMaxAmountOfAssetToDistribute(_amm, _assetId, _weekId).toString())
  }

  @Callable(i)
  func view_claimRewards(_trader: String, _assetId: String, _period: Int) = {
    throw(totalRewardForTraderInAsset(_trader, _assetId, [_period]).toString())
  }

  @Callable(i)
  func view_calcReward(_trader: String, _amm: String, _assetId: String, _period: Int) = {
      throw(rewardForTraderInAssetInPeriod(_amm, _assetId, _trader, _period).toString())
  }

  @Callable(i)
  func view_claimAllRewards(_trader: String, _assetId: String, _periods: String) = {
    let result = claimAllRewardForPeriodForTrader(_trader, _assetId, _periods)
    throw(result._1.toString() + "," + getTotalClaimedForTraderAndAsset(_trader, _assetId).toString())
  }

  @Callable(i)
  func claimAllRewards(_assetId: String, _periods: String) = {
    let trader = i.caller.toString()
    if (_periods.contains(getWeekId(TIME).toString())) then {
      throw("Can not claim rewards for current week")
    } else {
      let (amount, result) = claimAllRewardForPeriodForTrader(trader, _assetId, _periods)
      if (amount == 0) 
        then throw("Nothing to claim") 
        else result
    }
  }

  @Callable(i)
  func attachRewardAsset( _assetId: String, _maxAmountPerPeriod: Int) = {
    if (
      !initialized()
      || i.caller != adminAddress()
    ) then {
      throw("Invalid attachRewardAsset params")
    } else {
      let amms = getAmms()
      let rewardAssetIds = getRewardAssetIds()

      let newRewardAssetIds = if (rewardAssetIds.containsElement(_assetId)) then rewardAssetIds else rewardAssetIds :+ _assetId

      [
        IntegerEntry(getAssetMaxAmountPerPeriodKey(_assetId), _maxAmountPerPeriod),
        StringEntry(k_rewardAssetIds, listToStr(newRewardAssetIds))
      ]
    }
  }

  @Callable(i)
  func attachRewards(_amm: String, _assetId: String, _rewardRate: Int) = {
    if (
      !initialized()
      || i.caller != adminAddress()
      || !isWhitelist(_amm)
    ) then {
      throw("Invalid attachRewards params")
    } else {
      let amms = getAmms()
      let rewardAssetIds = getRewardAssetIds()

      let newAmms = if (amms.containsElement(_amm)) then amms else amms :+ _amm
      let newRewardAssetIds = if (rewardAssetIds.containsElement(_assetId)) then rewardAssetIds else rewardAssetIds :+ _assetId

      [
        IntegerEntry(getAmmRewardRateKey(_amm, _assetId), _rewardRate),
        StringEntry(k_amms, listToStr(newAmms)),
        StringEntry(k_rewardAssetIds, listToStr(newRewardAssetIds))
      ]
    }
  }

  @Callable(i)
  func notifyFees(_trader: String, _fee: Int) = {
    let amm = i.caller.toString()
    if (
      !isWhitelist(amm)
      || !initialized()
    ) then {
      throw("Invalid notifyFees params")
    } else {
      let actualFee = _fee.usdnToDecimals()
      let weekId = getWeekId(TIME)

      updateAmmFees(
        amm,
        _trader,
        weekId,
        actualFee
      )
    }
  }

  @Callable(i)
  func notifyNotional(_trader: String, _notional: Int) = {
    let amm = i.caller.toString()
    if (
      !isWhitelist(amm)
      || !initialized()
    ) then {
      throw("Invalid notifyNotional params")
    } else {
      let actualNotional = _notional.usdnToDecimals()
      let lastNotional = getLastNotional(amm, _trader)
      let weekId = getWeekId(TIME)
      let weekStart = getWeekStart(weekId)
      let weekEnd = getWeekEnd(weekId)
      let t = weekEnd - weekStart
      let oldRunningAverage = getTraderAverageNotionalInPeriod(amm, _trader, weekId, lastNotional)
      let w = (weekEnd - TIME).divd(t)

      let oldTraderAmmScore = getTraderScoreInPeriod(amm, _trader, weekId)
      let oldTotalAmmScore = getTotalScoreInPeriod(amm, weekId)
      let fees = getFeesInPeriod(amm, _trader, weekId)

      let newRunningAverage = oldRunningAverage + actualNotional.muld(w) - lastNotional.muld(w)
      let newTraderAmmScore = (fees.powd(A)).muld(newRunningAverage.powd(DECIMAL_UNIT - A))
      let newTotalAmmScoreInPeriod = oldTotalAmmScore - oldTraderAmmScore + newTraderAmmScore

      updateAmmData(
        amm,
        _trader,
        weekId,
        newRunningAverage,
        actualNotional,
        newTraderAmmScore,
        newTotalAmmScoreInPeriod
      )
    }
  }

  @Verifier(tx)
  func verify() = sigVerify(tx.bodyBytes, tx.proofs[0], adminPublicKey())