# This is a vAMM + Exchange contract
#
{-# STDLIB_VERSION 5 #-}
{-# SCRIPT_TYPE ACCOUNT #-}
{-# CONTENT_TYPE DAPP #-}

##### Key constants #####

# Oracle keys
let ora_k_price = "price"

# AMM Balance
let k_balance = "k_balance"

# Trader Position   
let k_positionSize = "k_positionSize"
let k_positionMargin = "k_positionMargin"
let k_pon = "k_pon"
let k_positionLstUpdCPF = "k_positionFraction"

# Global initialization state
let k_initialized = "k_initialized"

# Exchange settings
let k_fee = "k_fee"
let k_fundingPeriod = "k_fundingPeriod"
let k_initMarginRatio = "k_initMarginRatio"
let k_mmr = "k_mmr"
let k_liquidationFeeRatio = "k_liquidationFeeRatio"

# Funding state
let k_latestCPF = "k_latestPremiumFraction"
let k_nextFundingBlock = "k_nextFundingBlockMinTimestamp"
let k_fundingRate = "k_fundingRate"

# AMM State
let k_qtAstR = "k_qtAstR"
let k_bsAstR = "k_bsAstR"
let k_baseAssetDeltaThisFundingPeriod = "k_baseAssetDelta"
let k_totalPositionSize = "k_totalPositionSize"
let k_cumulativeNotional = "k_cumulativeNotional"
let k_openInteresetNotional = "k_openInteresetNotional"

##### Updateable (environment) constants ##### 
let ADMIN_ADDRESS = Address(base58'3MseEJNEHkYhvcHre6Mann1F8e27S1qptdg')
let ADMIN_PUBLIC_KEY = base58'A6ZtwikNTr19YpC1t6HnNGCBJF6GTx62DhEkJpgpzpmL'
let USDN = base58'HezsdQuRDtzksAYUy97gfhKy7Z1NW2uXYSHA3bgqenNZ'
let USDN_STAKING = Address(base58'3N9LkJahTMx41wGhSxLS42prCZtRCp4dhTs')
let ORACLE = Address(base58'3N4NS7d4Jo9a6F14LiFUKKYVdUkkf2eP4Zx')
let FEES_ACCOUNT = Address(base58'3MseEJNEHkYhvcHre6Mann1F8e27S1qptdg')
let INSURANCE_ADDRESS = Address(base58'3MzXE3znRvRJTNdvCtPXBRp6Bx5HSTsc3rS')

##### Core constants #####

let DIR_LONG                = 1
let DIR_SHORT               = 2
let FUNDING_BLOCK_INTERVAL  = 60

let SECONDS = 1000
let DECIMAL_UNIT = 1 * (10 * 10 * 10 * 10 * 10 * 10)
let ONE_DAY = 86400 * DECIMAL_UNIT

##### Helper functions #####

func divd(_x: Int, _y: Int) = fraction(_x, DECIMAL_UNIT, _y, HALFEVEN)
func muld(_x: Int, _y: Int) = fraction(_x, _y, DECIMAL_UNIT, HALFEVEN)
func abs(_x: Int) = if (_x > 0) then _x else -_x

func toCompositeKey(_key: String, _address: String) = _key + "_" + _address

##### Validator functions #####

func requireMoreMarginRatio(_marginRatio: Int, _baseMarginRatio: Int, _largerThanOrEqualTo: Boolean) = {
  let remainingMarginRatio = _marginRatio - _baseMarginRatio
  if (_largerThanOrEqualTo && remainingMarginRatio < 0) then {
    throw("Invalid margin")
  } else {
    if (!_largerThanOrEqualTo && remainingMarginRatio >= 0) then {
      throw("Invalid margin")
    } else {
      true
    }
  }
}

##### Accessor functions #####
func int(k: String) = this.getInteger(k).valueOrErrorMessage("no value for " + k)

func cbalance() = int(k_balance)
func fee() = int(k_fee)
func initMarginRatio() = int(k_initMarginRatio)
func qtAstR() = int(k_qtAstR)
func bsAstR() = int(k_bsAstR)
func baseAssetDeltaThisFundingPeriod() = int(k_baseAssetDeltaThisFundingPeriod)
func totalPositionSize() = int(k_totalPositionSize)
func cumulativeNotional() = int(k_cumulativeNotional)
func latestCPF() = int(k_latestCPF)
func openInteresetNotional() = int(k_openInteresetNotional)
func nextFundingBlockTimestamp() = int(k_nextFundingBlock)
func fundingPeriodRaw() = int(k_fundingPeriod)
func fundingPeriodDecimal() = fundingPeriodRaw() * DECIMAL_UNIT
func fundingPeriodSeconds() = fundingPeriodRaw() * SECONDS
func mmr() = int(k_mmr)
func liquidationFeeRatio() = int(k_liquidationFeeRatio)

func getPosition(invesor: String) = {
  let positionSizeOpt = this.getInteger(k_positionSize.toCompositeKey(invesor))
  match (positionSizeOpt) {
      case positionSize: Int => (
        positionSize,
        this.getIntegerValue(k_positionMargin.toCompositeKey(invesor)),
        this.getIntegerValue(k_pon.toCompositeKey(invesor)),
        this.getIntegerValue(k_positionLstUpdCPF.toCompositeKey(invesor))
      )
      case _ => (0, 0, 0, 0)
    }
}

func requireOpenPosition(_trader: String) = {
    let (
      positionSize,
      positionMargin,
      pon,
      positionLstUpdCPF
    ) = getPosition(_trader)

    if (positionSize == 0) then {
      throw("No open position")
    } else {
      true
    }
}

func initialized() = this.getBoolean(k_initialized).valueOrElse(false)

##### Internal functions #####
func updateReserve(_isAdd: Boolean, _quoteAssetAmount: Int, _baseAssetAmount: Int) = {
  if (_isAdd) then {
    (
      qtAstR() + _quoteAssetAmount,
      bsAstR() - _baseAssetAmount,
      baseAssetDeltaThisFundingPeriod() - _baseAssetAmount,
      totalPositionSize() + _baseAssetAmount,
      cumulativeNotional() + _quoteAssetAmount
    )
  } else {
    (
      qtAstR() - _quoteAssetAmount,
      bsAstR() + _baseAssetAmount,
      baseAssetDeltaThisFundingPeriod() + _baseAssetAmount,
      totalPositionSize() - _baseAssetAmount,
      cumulativeNotional() - _quoteAssetAmount
    )
  }
}

func swapInput(_isAdd: Boolean, _quoteAssetAmoun: Int) = {
  let _qtAstR = qtAstR()
  let _bsAstR = bsAstR()
  let k = muld(_qtAstR, _bsAstR)
  let qtAstRAfter = if (_isAdd) then {
    _qtAstR + _quoteAssetAmoun
  } else {
    _qtAstR - _quoteAssetAmoun
  }

  let bsAstRAfter = divd(k, qtAstRAfter)
  let amountBaseAssetBoughtAbs = abs(bsAstRAfter - _bsAstR)
  let amountBaseAssetBought = if (_isAdd) then {
    amountBaseAssetBoughtAbs
  } else {
    -amountBaseAssetBoughtAbs
  }

  let (
    qtAstRAfter1,
    bsAstRAfter1,
    baseAssetDeltaThisFundingPeriodAfter1,
    totalPositionSizeAfter1,
    cumulativeNotionalAfter1
  ) = updateReserve(_isAdd, _quoteAssetAmoun, amountBaseAssetBoughtAbs)

  (
    amountBaseAssetBought,
    qtAstRAfter1,
    bsAstRAfter1,
    baseAssetDeltaThisFundingPeriodAfter1,
    totalPositionSizeAfter1,
    cumulativeNotionalAfter1
  )
}

func calcRemainMarginWithFundingPayment(
  _oldPositionSize: Int, 
  _oldPositionMargin: Int, 
  _oldPositionLstUpdCPF: Int, 
  _marginDelta: Int
) = {
  let _latestCPF = latestCPF()
  let fundingPayment = if (_oldPositionSize != 0) then {
    muld((_latestCPF - 
            _oldPositionLstUpdCPF), _oldPositionSize)
  } else {
    0
  }
  let signedMargin = _marginDelta - fundingPayment + _oldPositionMargin
  let (remainMargin, badDebt) = if (signedMargin < 0) then {
    (0, abs(signedMargin))
  } else {
    (abs(signedMargin), 0)
  }

  (remainMargin, badDebt, fundingPayment, _latestCPF)
}

func getOutputPriceWithReserves(
  _add: Boolean, 
  _baseAssetAmount: Int, 
  _quoteAssetPoolAmount: Int, 
  _baseAssetPoolAmount: Int
) = {
  if (_baseAssetAmount == 0) then {
    throw("Invalid base asset amount")
  } else {
    let k = muld(_quoteAssetPoolAmount, _baseAssetPoolAmount)
    let baseAssetPoolAmountAfter = if (_add) then {
      _baseAssetPoolAmount + _baseAssetAmount 
    } else {
      _baseAssetPoolAmount - _baseAssetAmount
    }

    let quoteAssetAfter = divd(k, baseAssetPoolAmountAfter)
    let quoteAssetSold = abs(quoteAssetAfter - _quoteAssetPoolAmount)

    let (
      qtAstRAfter1,
      bsAstRAfter1,
      baseAssetDeltaThisFundingPeriodAfter1,
      totalPositionSizeAfter1,
      cumulativeNotionalAfter1
    ) = updateReserve(!_add, quoteAssetSold, _baseAssetAmount)

    (
      quoteAssetSold,
      qtAstRAfter1,
      bsAstRAfter1,
      baseAssetDeltaThisFundingPeriodAfter1,
      totalPositionSizeAfter1,
      cumulativeNotionalAfter1
    )
  }
}

func getPositionNotionalAndUnrealizedPnl(_trader: String) = {
  let (
      positionSize,
      positionMargin,
      pon,
      positionLstUpdCPF
    ) = getPosition(_trader)

    let positionSizeAbs = abs(positionSize)
    if  (positionSizeAbs == 0) then {
      throw("Invalid position size")
    } else {
      let isShort = positionSize < 0
      let (positionNotional, x1, x2, x3) = getOutputPriceWithReserves(
        !isShort,
        positionSizeAbs,
        qtAstR(),
        bsAstR()
      )

      let unrealizedPnl = if (isShort) then {
        pon - positionNotional
      } else {
        positionNotional - pon
      }
      (
        positionNotional,
        unrealizedPnl
      )
    }
}

func getOracleTwapPrice() = {
  ORACLE.getIntegerValue(ora_k_price)
}

func getTwapSpotPrice() = {
  divd(qtAstR(), bsAstR())
}

func getMarginRatio(_trader: String) = {
    let (
      positionSize,
      positionMargin,
      pon,
      positionLstUpdCPF
    ) = getPosition(_trader)

    let (positionNotional, unrealizedPnl) = getPositionNotionalAndUnrealizedPnl(_trader)
    let (remainMargin, badDebt) = calcRemainMarginWithFundingPayment(
        positionSize,
        positionMargin,
        positionLstUpdCPF,
        unrealizedPnl
    )
    divd(remainMargin - badDebt, positionNotional)
}

func internalClosePosition(_trader: String) = {
    let (
      positionSize,
      positionMargin,
      pon,
      positionLstUpdCPF
    ) = getPosition(_trader)

    let (x1, unrealizedPnl) = getPositionNotionalAndUnrealizedPnl(_trader)
    let (remainMargin, badDebt, x2) = calcRemainMarginWithFundingPayment(
        positionSize, 
        positionMargin, 
        positionLstUpdCPF,
        unrealizedPnl
    )

    let exchangedPositionSize = -positionSize
    let realizedPnl = unrealizedPnl
    let marginToVault = -remainMargin

    let (
      exchangedQuoteAssetAmount, 
      quoteAssetReserveAfter,
      bsAstRAfter,
      baseAssetDeltaThisFundingPeriodAfter,
      totalPositionSizeAfter,
      cumulativeNotionalAfter 
    ) = getOutputPriceWithReserves(
        positionSize > 0,
        abs(positionSize),
        qtAstR(),
        bsAstR()
    )
    
    let openInteresetNotionalAfter = openInteresetNotional() - pon
    (
      exchangedPositionSize,
      badDebt,
      realizedPnl,
      marginToVault,
      quoteAssetReserveAfter,
      bsAstRAfter,
      baseAssetDeltaThisFundingPeriodAfter,
      totalPositionSizeAfter,
      cumulativeNotionalAfter,
      openInteresetNotionalAfter,
      exchangedQuoteAssetAmount
    )
}

func updateSettings(
  _initMarginRatio: Int,
  _mmr: Int,
  _liquidationFeeRatio: Int,
  _fundingPeriod: Int,
  _fee: Int
) = {
  [
    IntegerEntry(k_initMarginRatio, _initMarginRatio),
    IntegerEntry(k_mmr, _mmr),
    IntegerEntry(k_liquidationFeeRatio, _liquidationFeeRatio),
    IntegerEntry(k_fundingPeriod, _fundingPeriod),
    IntegerEntry(k_fee, _fee)
  ]
}

func updateFunding(
  _baseADTFP: Int,
  _nextFundingBlock: Int,
  _latestCPF: Int,
  _fundingRate: Int
) = {
  [
    IntegerEntry(k_baseAssetDeltaThisFundingPeriod, _baseADTFP),
    IntegerEntry(k_nextFundingBlock, _nextFundingBlock),
    IntegerEntry(k_latestCPF, _latestCPF),
    IntegerEntry(k_fundingRate, _fundingRate)
  ]
}

func updatePosition(
  _address: String,
  _size: Int,
  _margin: Int,
  _openNotinal: Int,
  _LstUpdCPF: Int
) = {
  [
    IntegerEntry(k_positionSize.toCompositeKey(_address), _size),
    IntegerEntry(k_positionMargin.toCompositeKey(_address), _margin),
    IntegerEntry(k_pon.toCompositeKey(_address), _openNotinal),
    IntegerEntry(k_positionLstUpdCPF.toCompositeKey(_address), _LstUpdCPF)
  ]
}

func updateAmm(
  _qtAstR: Int,
  _bsAstR: Int,
  _baseAssetDeltaThisFundingPeriodAfter: Int,
  _totalPositionSizeAfter: Int,
  _cumulativeNotionalAfter: Int,
  _openInteresetNotional: Int
) = {
  [
    IntegerEntry(k_qtAstR, _qtAstR),
    IntegerEntry(k_bsAstR, _bsAstR),
    IntegerEntry(k_baseAssetDeltaThisFundingPeriod, _baseAssetDeltaThisFundingPeriodAfter),
    IntegerEntry(k_totalPositionSize, _totalPositionSizeAfter),
    IntegerEntry(k_cumulativeNotional, _cumulativeNotionalAfter),
    IntegerEntry(k_openInteresetNotional, _openInteresetNotional)
  ]
}

func deletePosition(
  _address: String
) = {
  [
    DeleteEntry(k_positionSize.toCompositeKey(_address)),
    DeleteEntry(k_positionMargin.toCompositeKey(_address)),
    DeleteEntry(k_pon.toCompositeKey(_address)),
    DeleteEntry(k_positionLstUpdCPF.toCompositeKey(_address))
  ]
}

func withdraw(
  _address: Address,
  _amount: Int
) = {
  let balance = assetBalance(this, USDN)
  if (balance < _amount) then {
    throw("Unable to withdraw " + _amount.toString() + " from contract balance " + balance.toString())
  } else {
    [
      ScriptTransfer(_address, _amount, USDN)
    ]
  }
}

func writeConstants() = {
  [
    StringEntry("ADMIN_ADDRESS", ADMIN_ADDRESS.toString()),
    StringEntry("USDN", USDN.toBase58String()),
    StringEntry("USDN_STAKING", USDN_STAKING.toString()),
    StringEntry("ORACLE", ORACLE.toString())
  ]
}

func upblc(i: Int) = {
  if (i < 0) then {
    throw("Balance")
  } else {
    [
      IntegerEntry(k_balance, i)
    ]
  }
}

func transferFee(i: Int) = {
  [
    ScriptTransfer(FEES_ACCOUNT, i, USDN)
  ]
}


##### Callable functions #####

@Callable(i)
func initialize(
  _qtAstR: Int,
  _bsAstR: Int,
  _fundingPeriod: Int,
  _initMarginRatio: Int,
  _mmr: Int,
  _liquidationFeeRatio: Int,
  _fee: Int
) = {
  if (
    _qtAstR <= 0
    || _bsAstR <= 0
    || _fundingPeriod <= 0
    || _initMarginRatio <= 0
    || _mmr <= 0
    || _liquidationFeeRatio <= 0
    || i.caller != ADMIN_ADDRESS
    || initialized()
  ) then {
    throw("Invalid initialize parameters")
  } else {
    updateAmm(_qtAstR, _bsAstR, 0, 0, 0, 0)
    ++
    updateSettings(_initMarginRatio, _mmr, _liquidationFeeRatio, _fundingPeriod, _fee)
    ++
    updateFunding(
      0,
      lastBlock.timestamp + _fundingPeriod,
      0,
      0
    )
    ++
    upblc(0)
    ++
    writeConstants()
    ++
    [
      BooleanEntry(k_initialized, true)
    ]
  }
}

@Callable(i)
func decreasePosition(
  _direction: Int,
  _amount: Int,
  _leverage: Int,
  _minBaseAssetAmount: Int
) = {
  if (
    (_direction != DIR_LONG && _direction != DIR_SHORT)
    || _amount <= 0
    || (_leverage < 1 * DECIMAL_UNIT || _leverage > 3 * DECIMAL_UNIT)
    || !initialized()
    || !requireMoreMarginRatio(divd(DECIMAL_UNIT, _leverage), initMarginRatio(), true)
  ) then {
    throw("Invalid decreasePosition parameters")
  } else {
    let (
      oldPositionSize,
      oldPositionMargin,
      oldPositionOpenNotional,
      oldPositionLstUpdCPF
    ) = getPosition(i.caller.toString())
    let isNewPosition = oldPositionSize == 0
    let isSameDirection = if (oldPositionSize > 0) then {
      _direction == DIR_LONG
    } else {
      _direction == DIR_SHORT
    }
    let expandExisting = !isNewPosition && isSameDirection
    let isAdd = _direction == DIR_LONG
    
    let (
      newPositionSize,
      newPositionRemainMargin,
      newPosiionOpenNotional,
      newPositionLatestCPF,
      bsAstRAfter,
      qtAstRAfter,
      baseAssetDeltaThisFundingPeriodAfter,
      totalPositionSizeAfter,
      cumulativeNotionalAfter,
      openInteresetNotionalAfter
    ) = if (isNewPosition || expandExisting) then {
      throw("Use increasePosition to open new or increase position")
    } else {
      let openNotional = muld(_amount, _leverage)
      let (oldPositionNotional, unrealizedPnl) = getPositionNotionalAndUnrealizedPnl(i.caller.toString())
      if (oldPositionNotional > openNotional) then {
        let ( 
            exchangedPositionSize, 
            qtAstRAfter, 
            bsAstRAfter,
            baseAssetDeltaThisFundingPeriodAfter,
            totalPositionSizeAfter,
            cumulativeNotionalAfter
         ) = swapInput(isAdd, openNotional)
         let exchangedPositionSizeAbs = abs(exchangedPositionSize)

         if (_minBaseAssetAmount != 0 && exchangedPositionSizeAbs < _minBaseAssetAmount) then {
              throw("Too little basse asset exchanged, got " + exchangedPositionSizeAbs.toString() + " expected " + _minBaseAssetAmount.toString())
          } else {
            let realizedPnl = if (oldPositionSize != 0) then {
              divd(muld(unrealizedPnl, exchangedPositionSizeAbs), oldPositionSize)
            } else {
              0
            }
            let (remainMargin, badDebt, fundingPayment, oldLatestCPF) = 
              calcRemainMarginWithFundingPayment(
                  oldPositionSize, 
                  oldPositionMargin, 
                  oldPositionLstUpdCPF, 
                  realizedPnl
              )
            let exchangedQuoteAssetAmount = openNotional
            let unrealizedPnlAfter = unrealizedPnl - realizedPnl
            let remainOpenNotional = if (oldPositionSize > 0) then {
              oldPositionNotional - exchangedQuoteAssetAmount - unrealizedPnlAfter
            } else {
              unrealizedPnlAfter + oldPositionNotional - exchangedQuoteAssetAmount
            }

            (
              oldPositionSize + exchangedPositionSize, # positionSize
              remainMargin, # remainMargin
              abs(remainOpenNotional), # pon
              oldLatestCPF, # latestCPF
              bsAstRAfter, # bsAstRAfter
              qtAstRAfter, # qtAstRAfter
              baseAssetDeltaThisFundingPeriodAfter, # baseAssetDeltaThisFundingPeriodAfter
              totalPositionSizeAfter, # totalPositionSizeAfter
              cumulativeNotionalAfter, # cumulativeNotionalAfter
              openInteresetNotional() - openNotional # openInteresetNotionalAfter
            )
          }
      } else {
        throw("Close position first")
      }
    }
    
    updatePosition(
      i.caller.toString(),
      newPositionSize,
      newPositionRemainMargin,
      newPosiionOpenNotional,
      newPositionLatestCPF
    ) 
    ++
    updateAmm(
      qtAstRAfter,
      bsAstRAfter,
      baseAssetDeltaThisFundingPeriodAfter,
      totalPositionSizeAfter,
      cumulativeNotionalAfter,
      openInteresetNotionalAfter
    )
  }
}

@Callable(i)
func increasePosition(
  _direction: Int,
  _leverage: Int,
  _minBaseAssetAmount: Int
) = {
  let _rawAmount = i.payments[0].amount
  if (
    (_direction != DIR_LONG && _direction != DIR_SHORT)
    || _rawAmount <= 0
    || (_leverage < 1 * DECIMAL_UNIT || _leverage > 3 * DECIMAL_UNIT)
    || !initialized()
    || i.payments[0].assetId != USDN
    || !requireMoreMarginRatio(divd(DECIMAL_UNIT, _leverage), initMarginRatio(), true)
  ) then {
    throw("Invalid increasePosition parameters")
  } else {
    let feeAmount = muld(_rawAmount, fee())
    let _amount = _rawAmount - feeAmount
    let (
      oldPositionSize,
      oldPositionMargin,
      oldPositionOpenNotional,
      oldPositionLstUpdCPF
    ) = getPosition(i.caller.toString())
    let isNewPosition = oldPositionSize == 0
    let isSameDirection = if (oldPositionSize > 0) then {
      _direction == DIR_LONG
    } else {
      _direction == DIR_SHORT
    }
    let expandExisting = !isNewPosition && isSameDirection
    let isAdd = _direction == DIR_LONG
    
    let (
      newPositionSize,
      newPositionRemainMargin,
      newPosiionOpenNotional,
      newPositionLatestCPF,
      bsAstRAfter,
      qtAstRAfter,
      baseAssetDeltaThisFundingPeriodAfter,
      totalPositionSizeAfter,
      cumulativeNotionalAfter,
      openInteresetNotionalAfter
    ) = if (isNewPosition || expandExisting) then {
      let openNotional = muld(_amount, _leverage)
      let ( 
        amountBaseAssetBought,
        qtAstRAfter, 
        bsAstRAfter,
        baseAssetDeltaThisFundingPeriodAfter,
        totalPositionSizeAfter,
        cumulativeNotionalAfter
      ) = swapInput(isAdd, openNotional)
       
      if (_minBaseAssetAmount != 0 && abs(amountBaseAssetBought) < _minBaseAssetAmount) then {
         throw("Limit error: " + abs(amountBaseAssetBought).toString() + " < " + _minBaseAssetAmount.toString())
       } else {
        let newPositionSize = oldPositionSize + amountBaseAssetBought
        let increaseMarginRequirement = divd(openNotional, _leverage)
        let (remainMargin, x1, x2, oldLatestCPF) =
          calcRemainMarginWithFundingPayment(
                oldPositionSize, 
                oldPositionMargin, 
                oldPositionLstUpdCPF, 
                increaseMarginRequirement
            )
        (
          newPositionSize, # positionSize
          remainMargin, # remainMargin
          oldPositionOpenNotional + openNotional, # pon
          oldLatestCPF, # latestCPF
          bsAstRAfter, # bsAstRAfter
          qtAstRAfter, # qtAstRAfter
          baseAssetDeltaThisFundingPeriodAfter, # baseAssetDeltaThisFundingPeriodAfter
          totalPositionSizeAfter, # totalPositionSizeAfter
          cumulativeNotionalAfter, # cumulativeNotionalAfter
          openInteresetNotional() + openNotional # openInteresetNotionalAfter
        )
       }
    } else {
      let openNotional = muld(_amount, _leverage)
      let (oldPositionNotional, unrealizedPnl) = getPositionNotionalAndUnrealizedPnl(i.caller.toString())
      if (oldPositionNotional > openNotional) then {
        throw("Use decreasePosition to decrease position size")
      } else {
        throw("Close position first")
      }
      
    }
    
    strict stake = invoke(
      USDN_STAKING,
      "lockNeutrino",
      [],
      [AttachedPayment(USDN, _amount)]
    )
    
    updatePosition(
      i.caller.toString(),
      newPositionSize,
      newPositionRemainMargin,
      newPosiionOpenNotional,
      newPositionLatestCPF
    ) 
    ++
    updateAmm(
      qtAstRAfter,
      bsAstRAfter,
      baseAssetDeltaThisFundingPeriodAfter,
      totalPositionSizeAfter,
      cumulativeNotionalAfter,
      openInteresetNotionalAfter
    )
    ++
    transferFee(feeAmount)
    ++
    upblc(cbalance() + _amount)
  }
}

@Callable(i)
func addMargin() = {
  let _rawAmount = i.payments[0].amount
  if (
    i.payments[0].assetId != USDN
    || !requireOpenPosition(i.caller.toString())
  ) then {
    throw("Invalid addMargin parameters")
  } else {
    let feeAmount = muld(_rawAmount, fee())
    let _amount = _rawAmount - feeAmount

    let (
      oldPositionSize,
      oldPositionMargin,
      oldPositionOpenNotional,
      oldPositionLstUpdCPF
    ) = getPosition(i.caller.toString())

    strict stake = invoke(
      USDN_STAKING,
      "lockNeutrino",
      [],
      [AttachedPayment(USDN, _amount)]
    )

    updatePosition(
      i.caller.toString(),
      oldPositionSize,
      oldPositionMargin + i.payments[0].amount,
      oldPositionOpenNotional,
      oldPositionLstUpdCPF
    )
    ++
    transferFee(feeAmount)
    ++
    upblc(cbalance() + _amount)
  }
}

@Callable(i)
func removeMargin(
  _amount: Int
) = {
  if (
    _amount <= 0
    || !requireOpenPosition(i.caller.toString())
  ) then {
    throw("Invalid removeMargin parameters")
  } else {
    let (
      oldPositionSize,
      oldPositionMargin,
      oldPositionOpenNotional,
      oldPositionLstUpdCPF
    ) = getPosition(i.caller.toString())

    let marginDelta = -_amount
    let (remainMargin, badDebt, x1, latestCPF1) =
      calcRemainMarginWithFundingPayment(
        oldPositionSize,
        oldPositionMargin,
        oldPositionLstUpdCPF,
        marginDelta
    )
    if (badDebt != 0) then {
      throw("Invalid added margin amount")
    } else {
      strict unstake = invoke(
        USDN_STAKING,
        "unlockNeutrino",
        [_amount, USDN.toBase58String()],
        []
      )
      
      updatePosition(
        i.caller.toString(),
        oldPositionSize,
        remainMargin,
        oldPositionOpenNotional,
        latestCPF1
      )
      ++
      withdraw(i.caller, _amount)
      ++
      upblc(cbalance() - _amount)
    }
  }
}

@Callable(i)
func closePosition() = {
    if (!requireOpenPosition(i.caller.toString())
  ) then {
    throw("Invalid closePosition parameters")
  } else {
    let (
          x1,
          badDebt,
          realizedPnl,
          marginToVault,
          quoteAssetReserveAfter,
          bsAstRAfter,
          baseAssetDeltaThisFundingPeriodAfter,
          totalPositionSizeAfter,
          cumulativeNotionalAfter,
          openInteresetNotionalAfter
    ) = internalClosePosition(i.caller.toString())

    if (badDebt > 0) then {
      throw("Unable to close position with bad debt")
    } else {
      let withdrawAmount = abs(marginToVault)

      let bd = cbalance() - withdrawAmount
      let (nb, fromi) = if (bd < 0) then {
        (0, abs(bd))
      } else {
        (bd, 0)
      }

      strict x = if (fromi > 0) then {
        strict withdrawInsurance = invoke(
          INSURANCE_ADDRESS,
          "withdraw",
          [fromi],
          []
        )
        []
      } else {
        []
      }

      strict unstake = invoke(
        USDN_STAKING,
        "unlockNeutrino",
        [withdrawAmount - fromi, USDN.toBase58String()],
        []
      )
      
      deletePosition(i.caller.toString()) 
      ++ 
      updateAmm(
        quoteAssetReserveAfter,
        bsAstRAfter,
        baseAssetDeltaThisFundingPeriodAfter,
        totalPositionSizeAfter,
        cumulativeNotionalAfter,
        openInteresetNotionalAfter
      )
      ++
      withdraw(i.caller, withdrawAmount)
      ++
      upblc(nb)
    }
  }
}

@Callable(i)
func liquidate(_trader: String) = {
  if (
    !requireMoreMarginRatio(getMarginRatio(_trader), mmr(), false)
    || !initialized()
  ) then {
    throw("Unable to liquidate")
  } else {
    let (
      x1,
      badDebt,
      x2,
      marginToVault,
      quoteAssetReserveAfter,
      bsAstRAfter,
      baseAssetDeltaThisFundingPeriodAfter,
      totalPositionSizeAfter,
      cumulativeNotionalAfter,
      openInteresetNotionalAfter,
      exchangedQuoteAssetAmount
    ) = internalClosePosition(_trader)
    let feeToLiquidator = muld(exchangedQuoteAssetAmount, liquidationFeeRatio()) / 2
    let (liquidationBadDebt, remainMargin, totalBadDebt) = if (feeToLiquidator > marginToVault) then {
      (
        feeToLiquidator - marginToVault, # liquidationBadDebt
        marginToVault, # remainMargin
        badDebt + feeToLiquidator - marginToVault # totalBadDebt
      )
    } else {
      (
        0, # liquidationBadDebt
        marginToVault - feeToLiquidator, 
        badDebt
      )
    }

    let bd = cbalance() - feeToLiquidator
    let (nb, fromi) = if (bd < 0) then {
      (0, abs(bd))
    } else {
      (bd, 0)
    }

    strict x = if (fromi > 0) then {
      strict withdrawInsurance = invoke(
        INSURANCE_ADDRESS,
        "withdraw",
        [fromi],
        []
      )
      []
    } else {
      []
    }

    strict unstake = invoke(
      USDN_STAKING,
      "unlockNeutrino",
      [feeToLiquidator - fromi, USDN.toBase58String()],
      []
    )

    deletePosition(_trader)
    ++ 
    updateAmm(
      quoteAssetReserveAfter,
      bsAstRAfter,
      baseAssetDeltaThisFundingPeriodAfter,
      totalPositionSizeAfter,
      cumulativeNotionalAfter,
      openInteresetNotionalAfter
    )
    ++
    withdraw(i.caller, feeToLiquidator)
    ++
    upblc(nb)
  }
}

@Callable(i)
func payFunding() = {
  let fundingBlockTimestamp = nextFundingBlockTimestamp()
  if (
    lastBlock.timestamp < fundingBlockTimestamp
    || !initialized()
  ) then {
    throw("Invalid funding block timestamp: " + lastBlock.timestamp.toString() + " < " + fundingBlockTimestamp.toString())
  } else {
    let underlyingPrice = getOracleTwapPrice()
    let spotTwapPrice = getTwapSpotPrice()
    let premium = spotTwapPrice - underlyingPrice
    let premiumFraction = divd(muld(premium, fundingPeriodDecimal()), ONE_DAY)
    let totalTraderPositionSize = totalPositionSize()
    let ammFundingPaymentProfit = muld(premiumFraction, totalTraderPositionSize)
    let fundingAmount = abs(ammFundingPaymentProfit)
    if (ammFundingPaymentProfit < 0) then {
        strict withdrawInsurance = invoke(
          INSURANCE_ADDRESS,
          "withdraw",
          [fundingAmount],
          []
        )

        strict stake = invoke(
          USDN_STAKING,
          "lockNeutrino",
          [],
          [AttachedPayment(USDN, fundingAmount)]
        )

        upblc(cbalance() + fundingAmount)
    } else {
        strict unstake = invoke(
          USDN_STAKING,
          "unlockNeutrino",
          [fundingAmount, USDN.toBase58String()],
          []
        )

        strict depositInsurance = invoke(
          INSURANCE_ADDRESS,
          "deposit",
          [],
          [AttachedPayment(USDN, fundingAmount)]
        )

        upblc(cbalance() - fundingAmount)
    } ++ updateFunding(
      0,
      fundingBlockTimestamp + fundingPeriodSeconds(),
      latestCPF() + premiumFraction,
      divd(premiumFraction, underlyingPrice)
    )
  }
}

@Callable(i)
func view_getMarginRatio(_trader: String) = throw(getMarginRatio(_trader).toString())

@Verifier(tx)
func verify() = sigVerify(tx.bodyBytes, tx.proofs[0], ADMIN_PUBLIC_KEY)