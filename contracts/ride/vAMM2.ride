# This is a vAMM + Exchange contract
#
{-# STDLIB_VERSION 6 #-}
{-# SCRIPT_TYPE ACCOUNT #-}
{-# CONTENT_TYPE DAPP #-}

##### Key constants #####

# Oracle keys
let k_ora_key = "k_ora_key"             # Key in Index Price Oracle account to read price from
let k_ora_block_key = "k_ora_block_key" # Key for last updated block in oracle
let k_ora = "k_ora"                     # Address of Index Price oracle account

# AMM Balance
let k_balance = "k_balance" # How much of a trader's funds is controlled by this AMM

# Trader Position   
let k_positionSize = "k_positionSize"                 # Trader position size (base asset)
let k_positionMargin = "k_positionMargin"             # Trader position margin (quote asset) - how much quote asset is supporting the position
let k_positionOpenNotional = "k_positionOpenNotional" # Trader position open notional - how much quote asset they have borrowed
let k_positionLastUpdatedCumulativePremiumFraction = "k_positionFraction"        # Trader position last updated cumulative premium fraction
let k_positionClosedDate = "k_positionClosedDate"     # When position was closed
let k_positionAsset = "k_positionAsset"               # Asset of position

# Global initialization state
let k_initialized = "k_initialized"                       # If AMM was properly initialized
let k_paused = "k_paused"

# Exchange settings
let k_fee = "k_fee"                                       # Exchange fee. Default is 1%. 1/2 goes to stakers, 1/2 goes to insurance fund
let k_fundingPeriod = "k_fundingPeriod"                   # Funding period. By default funding is paid once per hour
let k_initMarginRatio = "k_initMarginRatio"               # Initial margin ratio. Controls how much leverage can be applied when position is created
let k_maintenanceMarginRatio = "k_mmr"                    # Maintenance margin ratio (MMR). When MR < MMR position can be liquidated
let k_liquidationFeeRatio = "k_liquidationFeeRatio"       # % of position size liquidator will get for himself. 1/2 of this goes to liquidator, 1/2 - to insurance fund
let k_partialLiquidationRatio = "k_partLiquidationRatio"  # % of position notional that will be liquidated in case 0 < MR < MMR
let k_spreadLimit = "k_spreadLimit"                       # abs((marketPrice - oraclePrice) / oraclePrice). If over spread limit, liquidations consult oracle price
let k_maxPriceImpact = "k_maxPriceImpact"                 # maximum price impact per order
let k_maxPriceSpread = "k_maxPriceSpread"                 # max spread between Index and Market Price
let k_maxOpenNotional = "k_maxOpenNotional"               # max open notional in market

# TWAP data
let k_lastDataStr = "k_lastDataStr"                       # List of last 15 TWAP computations (best case - we have a value for each of last 15 mins)
let k_lastMinuteId = "k_lastMinuteId"                     # ID of last minute, when price measurements was taken
let k_twapDataLastCumulativePrice = "k_twapDataLastCumulativePrice" # Last cumulative price data (previousPrice * minutesPriceLasted)
let k_twapDataLastPrice = "k_twapDataLastPrice"           # Last price value
let k_twapDataPreviousMinuteId = "k_twapDataPreviousMinuteId" # Previous minute id for current twap data

# Funding state
let k_latestLongCumulativePremiumFraction = "k_latestLongPremiumFraction" # Latest Cumulative Premium Fraction. (Part of Premium paid this funding period). Premium = MarkPrice - IndexPrice
let k_latestShortCumulativePremiumFraction = "k_latestShortPremiumFraction" # Latest Cumulative Premium Fraction. (Part of Premium paid this funding period). Premium = MarkPrice - IndexPrice
let k_nextFundingBlock = "k_nextFundingBlockMinTimestamp"         # Timestamp of Next block when funding becomes available
let k_longFundingRate = "k_longFundingRate"                       # Funding rate  Cumulative Premium Fraction / Index Price
let k_shortFundingRate = "k_shortFundingRate"                     # Funding rate  Cumulative Premium Fraction / Index Price

# AMM State
let k_quoteAssetReserve = "k_qtAstR"                      # Quote Asset Reserve (AMM)
let k_baseAssetReserve = "k_bsAstR"                       # Base Asset Reserve (AMM)
let k_quoteAssetWeight = "k_qtAstW"                       # Quote Asset Weight
let k_baseAssetWeight = "k_bsAstW"                        # Base Asset Weight
let k_totalPositionSize = "k_totalPositionSize"           # Total trader position size (in Base asset)
let k_totalLongPositionSize = "k_totalLongPositionSize"   # Total LONG trader position size (in Base asset)
let k_totalShortPositionSize = "k_totalShortPositionSize" # Total SHORT trader position size (in Base asset)
let k_cumulativeNotional = "k_cumulativeNotional"         # Cumulative Notional (all positions)
let k_openInterestNotional = "k_openInterestNotional"     # Open Interest Notional (all positions)
let k_openInterestShort = "k_openInterestShort"           # Open Interest Notional (short)
let k_openInterestLong = "k_openInterestLong"             # Open Interest Notional (long)

# Coordinator
let k_coordinatorAddress = "k_coordinatorAddress"         # Address of Coordinator (base contract that keeps references to all infrastructure)

# Coordinator keys
# let k_insurance_address = "k_insurance_address"   # Address of insurance contract
let k_vault_address = "k_vault_address"           # Address of vault contract
let k_admin_address = "k_admin_address"           # Address of admin account           
let k_admin_public_key = "k_admin_public_key"     # Pubic key of admin account
let k_quote_asset = "k_quote_asset"               # Address of quote asset (USDN in our case)
let k_quote_staking = "k_quote_staking"           # Address of quote asset staking contract (USDN staking in our case)
let k_staking_address = "k_staking_address"       # Address that should receive staking benefits
let k_miner_address = "k_miner_address"           # Liquidity mining contract address
let k_orders_address = "k_orders_address"         # Order executor contract address
let k_referral_address = "k_referral_address"     # Referral contract address
let k_manager_address = "k_manager_address"       # Fund manager address
let k_collateral_address = "k_collateral_address" # Collateral manager address
#let k_exchange_address = "k_exchange_address"     # Collateral manager address
let k_exchange_address = "k_exchange_address"     # Exchange manager address
let k_nft_manager_address = "k_nft_manager_address" # NFT manager address

# Collateral keys
let k_trader_market_asset_collateral = "k_trader_market_asset_collateral"

func toCompositeKey(_key: String, _address: String) = _key + "_" + _address

##### Coordinator data ##### 
func coordinator() = addressFromString(this.getStringValue(k_coordinatorAddress)).valueOrErrorMessage("Coordinator not set")
func adminAddress() = addressFromString(coordinator().getStringValue(k_admin_address))
func adminPublicKey() = fromBase58String(coordinator().getStringValue(k_admin_public_key))
func quoteAsset() = fromBase58String(coordinator().getStringValue(k_quote_asset))
func quoteAssetStaking() = addressFromString(coordinator().getStringValue(k_quote_staking)).valueOrErrorMessage("Quote asset staking not set")
func stakingAddress() = addressFromString(coordinator().getStringValue(k_staking_address)).valueOrErrorMessage("Staking not set")
func vaultAddress() = addressFromString(coordinator().getStringValue(k_vault_address)).valueOrErrorMessage("Vault not set") 
func minerAddress() = addressFromString(coordinator().getStringValue(k_miner_address)).valueOrErrorMessage("Miner not set")
func ordersAddress() = addressFromString(coordinator().getStringValue(k_orders_address)).valueOrErrorMessage("Orders not set")
func referralAddress() = addressFromString(coordinator().getStringValue(k_referral_address)).valueOrErrorMessage("Referral not set")
func nftManagerAddress() = addressFromString(coordinator().getStringValue(k_nft_manager_address)).valueOrErrorMessage("NFT Manager not set")
func collateralAddress() = addressFromString(coordinator().getStringValue(k_collateral_address)).valueOrErrorMessage("Collateral Manager not set")
func swapAddress() = addressFromString(coordinator().getString(k_exchange_address).valueOrErrorMessage("No swap address")).valueOrErrorMessage("Invalid swap address")

##### Collateral data ##### 
let k_whitelist_asset = "k_whitelist_asset"
func isWhitelistAsset(_assetId: String) = getBoolean(collateralAddress(), k_whitelist_asset.toCompositeKey(_assetId)).valueOrElse(false)

##### NFT Artifacts #####
let k_token_param = "k_token_param"
let k_token_type = "k_token_type"
let FEE_REDUCTION_TOKEN_TYPE = "fee_reduction"

##### Core constants #####

let DIR_LONG                = 1
let DIR_SHORT               = 2
let TWAP_INTERVAL           = 15
let ORACLE_INTERVAL         = 15

let SECONDS = 1000
let DECIMAL_NUMBERS = 6
let DECIMAL_UNIT = 1 * (10 * 10 * 10 * 10 * 10 * 10)
let ONE_DAY = 86400 * DECIMAL_UNIT
let ALL_FEES = 100
let PNL_OPTION_SPOT = 1
let PNL_OPTION_ORACLE = 2

##### Helper functions #####

func s(_x: Int) = _x.toString() + ","

func divd(_x: Int, _y: Int) = fraction(_x, DECIMAL_UNIT, _y, HALFEVEN)
func muld(_x: Int, _y: Int) = fraction(_x, _y, DECIMAL_UNIT, HALFEVEN)
func sqrtd(_x: Int) = sqrt(_x, DECIMAL_NUMBERS, DECIMAL_NUMBERS, HALFEVEN)
func powd(_x: Int, _y: Int) = pow(_x, DECIMAL_NUMBERS, _y, DECIMAL_NUMBERS, DECIMAL_NUMBERS, HALFEVEN)

func bdivd(_x: BigInt, _y: BigInt) = fraction(_x, DECIMAL_UNIT.toBigInt(), _y, HALFEVEN)
func bmuld(_x: BigInt, _y: BigInt) = fraction(_x, _y, DECIMAL_UNIT.toBigInt(), HALFEVEN)
func bsqrtd(_x: BigInt) = sqrt(_x, DECIMAL_NUMBERS, DECIMAL_NUMBERS, HALFEVEN)
func bpowd(_x: BigInt, _y: BigInt) = pow(_x, DECIMAL_NUMBERS, _y, DECIMAL_NUMBERS, DECIMAL_NUMBERS, HALFEVEN)

func abs(_x: Int) = if (_x > 0) then _x else -_x
func vmax(_x: Int, _y: Int) = if (_x >= _y) then _x else _y

func listToStr(_list: List[String]) = {
  func _join(accumulator: String, val: String) = accumulator + val + ","
  let newListStr = FOLD<20>(_list, "", _join)
  let newListStrU = newListStr.dropRight(1)
  let newListStrR = if (newListStrU.take(1) == ",") then newListStrU.drop(1) else newListStrU
  newListStrR
}

func strToList(_str: String) = _str.split(",")
func pushToQueue(_list: List[String], _maxSize: Int, _value: String) = if (_list.size() > _maxSize) then {
        _list.removeByIndex(0) :+ _value
      } else {
        _list :+ _value
      }

##### Accessor functions #####
func int(k: String) = this.getInteger(k).valueOrErrorMessage("no value for " + k)
func intOr(k: String, def: Int) = this.getInteger(k).valueOrElse(def)
func strA(_address: Address, _key: String) = {
  let val = _address.getString(_key).valueOrErrorMessage("No value for key " + _key)
  val
}

func intA(_address: Address, _key: String) = {
  let val = _address.getInteger(_key).valueOrErrorMessage("No value for key " + _key)
  val
}

func cbalance() = int(k_balance)
func fee() = int(k_fee)
func initMarginRatio() = int(k_initMarginRatio)
func qtAstR() = int(k_quoteAssetReserve)
func bsAstR() = int(k_baseAssetReserve)
func qtAstW() = intOr(k_quoteAssetWeight, DECIMAL_UNIT)
func bsAstW() = intOr(k_baseAssetWeight, DECIMAL_UNIT)
func totalPositionSize() = int(k_totalPositionSize)
func cumulativeNotional() = int(k_cumulativeNotional)
func openInterestNotional() = int(k_openInterestNotional)
func openInterestShort() = int(k_openInterestShort)
func openInterestLong() = int(k_openInterestLong)
func nextFundingBlockTimestamp() = int(k_nextFundingBlock)
func fundingPeriodRaw() = int(k_fundingPeriod)
func fundingPeriodDecimal() = fundingPeriodRaw() * DECIMAL_UNIT
func fundingPeriodSeconds() = fundingPeriodRaw() * SECONDS
func maintenanceMarginRatio() = int(k_maintenanceMarginRatio)
func liquidationFeeRatio() = int(k_liquidationFeeRatio)
func partialLiquidationRatio() = int(k_partialLiquidationRatio)
func spreadLimit() = int(k_spreadLimit)
func maxPriceImpact() = int(k_maxPriceImpact)
func maxPriceSpread() = int(k_maxPriceSpread)
func maxOpenNotional() = int(k_maxOpenNotional)
func latestLongCumulativePremiumFraction() = int(k_latestLongCumulativePremiumFraction)
func latestShortCumulativePremiumFraction() = int(k_latestShortCumulativePremiumFraction)
func totalShortPositionSize() = int(k_totalShortPositionSize)
func totalLongPositionSize() = int(k_totalLongPositionSize)

##### Order support #####
func getActualCaller(i: Invocation) = {
  ordersAddress().getString("k_sender").valueOrElse(i.caller.toString())
}

##### Validator functions #####
func requireMoreMarginRatio(_marginRatio: Int, _baseMarginRatio: Int, _largerThanOrEqualTo: Boolean) = {
  let remainingMarginRatio = _marginRatio - _baseMarginRatio
  if (_largerThanOrEqualTo && remainingMarginRatio < 0) then {
    throw("Invalid margin")
  } else {
    if (!_largerThanOrEqualTo && remainingMarginRatio >= 0) then {
      throw("Invalid margin")
    } else {
      true
    }
  }
}

# Returns latest cumulative premium fraction for a position (long for long position, short for short)
func latestCumulativePremiumFraction(
  _positionSize: Int
) = if (_positionSize == 0)
  then throw("Should not be called with _positionSize == 0")
  else if (_positionSize > 0)
    then latestLongCumulativePremiumFraction() 
    else latestShortCumulativePremiumFraction()

# Returns info on traders position
func getPosition(_trader: String) = {
  let positionSizeOpt = this.getInteger(k_positionSize.toCompositeKey(_trader))
  match (positionSizeOpt) {
      case positionSize: Int => (
        positionSize,
        this.getIntegerValue(k_positionMargin.toCompositeKey(_trader)),
        this.getIntegerValue(k_positionOpenNotional.toCompositeKey(_trader)),
        this.getIntegerValue(k_positionLastUpdatedCumulativePremiumFraction.toCompositeKey(_trader))
      )
      case _ => (0, 0, 0, 0)
    }
}

func getPositionAsset(_trader: String) = {
  let positionAssetOpt = this.getString(k_positionAsset.toCompositeKey(_trader))
  match (positionAssetOpt) {
    case positionAsset: String => positionAsset
    case _ => quoteAsset().toBase58String()
  }
}

# Checks that a trader have an open position
func requireOpenPosition(_trader: String) = {
    if (getPosition(_trader)._1 == 0) then {
      throw("No open position")
    } else {
      true
    }
}

# Checks if AMM was properly initialized
func initialized() = this.getBoolean(k_initialized).valueOrElse(false)

# Checks of AMM was paused
func paused() = this.getBoolean(k_paused).valueOrElse(false)

# Computes new AMM state (quoteAssetReserve, baseAssetReserve, totalPositionSize, cumulativeNotional)
func updateReserve(_isAdd: Boolean, _quoteAssetAmount: Int, _baseAssetAmount: Int) = {
  if (_isAdd) then {
    let newBase = bsAstR() - _baseAssetAmount
    if (newBase <= 0) then {
      throw("Tx lead to base asset reserve <= 0, revert")
    } else {
      (
        qtAstR() + _quoteAssetAmount,
        newBase,
        totalPositionSize() + _baseAssetAmount,
        cumulativeNotional() + _quoteAssetAmount
      )
    }
  } else {
    let newQuote = qtAstR() - _quoteAssetAmount
    if (newQuote <= 0) then {
      throw("Tx lead to base quote reserve <= 0, revert")
    } else {
      (
        newQuote,
        bsAstR() + _baseAssetAmount,
        totalPositionSize() - _baseAssetAmount,
        cumulativeNotional() - _quoteAssetAmount
      )
    }
  }
}

func calcInvariant(_qtAstR: Int, _qtAstW: Int, _bsAstR: Int, _bsAstW: Int) = {
  let bqtAstR = _qtAstR.toBigInt()
  let bqtAstW = _qtAstW.toBigInt()
  let bbsAstR = _bsAstR.toBigInt()
  let bbsAstW = _bsAstW.toBigInt()

  bqtAstR.bmuld(bqtAstW).bmuld(bbsAstR.bmuld(bbsAstW))
}

# Computes result of swapping a given amount of _quoteAssetAmount
# Returns full new AMM state, as well as amount of base asset bought / sold
# _isAdd - true when we are adding quote asset to AMM, false when removing
func swapInput(_isAdd: Boolean, _quoteAssetAmount: Int) = {
  let _qtAstR = qtAstR()
  let _bsAstR = bsAstR()
  let _qtAstW = qtAstW()
  let _bsAstW = bsAstW()

  let k = calcInvariant(_qtAstR, _qtAstW, _bsAstR, _bsAstW)
  let quoteAssetReserveAfter = if (_isAdd) then {
    _qtAstR + _quoteAssetAmount
  } else {
    _qtAstR - _quoteAssetAmount
  }

  let baseAssetReserveAfter = bdivd(k, quoteAssetReserveAfter.muld(_qtAstW).toBigInt()).toInt()
  let amountBaseAssetBoughtAbs = abs(baseAssetReserveAfter - _bsAstR).divd(_qtAstW)
  let amountBaseAssetBought = if (_isAdd) then {
    amountBaseAssetBoughtAbs
  } else {
    -amountBaseAssetBoughtAbs
  }
  
  let (
    quoteAssetReserveAfter1,
    baseAssetReserveAfter1,
    totalPositionSizeAfter1,
    cumulativeNotionalAfter1
  ) = updateReserve(_isAdd, _quoteAssetAmount, amountBaseAssetBoughtAbs)

  let priceBefore = divd(_qtAstR.muld(_qtAstW), _bsAstR.muld(_bsAstW))
  let marketPrice = divd(_quoteAssetAmount, amountBaseAssetBoughtAbs)
  let priceDiff = abs(priceBefore - marketPrice)
  let priceImpact = DECIMAL_UNIT - divd(priceBefore, (priceBefore + priceDiff))

  let maxPriceImpactValue = maxPriceImpact()
  if (priceImpact > maxPriceImpactValue) then {
    throw("Price impact " + priceImpact.toString() + " > max price impact " + maxPriceImpactValue.toString() 
      + " before quote asset: " + _qtAstR.toString()
      + " before base asset: " + _bsAstR.toString()
      + " quote asset amount to exchange: " + _quoteAssetAmount.toString()
      + " price before: " + priceBefore.toString()
      + " marketPrice: " + marketPrice.toString()
    )
  } else {
    (
      amountBaseAssetBought,
      quoteAssetReserveAfter1,
      baseAssetReserveAfter1,
      totalPositionSizeAfter1,
      cumulativeNotionalAfter1
    )
  }
}

# Computes position remaining margin with funding payment
func calcRemainMarginWithFundingPayment(
  _oldPositionSize: Int, 
  _oldPositionMargin: Int, 
  _oldPositionCumulativePremiumFraction: Int, 
  _marginDelta: Int
) = {
  let fundingPayment = if (_oldPositionSize != 0) then {
    let _latestCumulativePremiumFraction = latestCumulativePremiumFraction(_oldPositionSize)
    muld((_latestCumulativePremiumFraction - _oldPositionCumulativePremiumFraction), _oldPositionSize)
  } else {
    0
  }
  let signedMargin = _marginDelta - fundingPayment + _oldPositionMargin
  let (remainMargin, badDebt) = if (signedMargin < 0) then {
    (0, abs(signedMargin))
  } else {
    (abs(signedMargin), 0)
  }

  (remainMargin, badDebt, fundingPayment)
}

# Computes result of swapping a given amount of _baseAssetAmount
# Returns full new AMM state, as well as amount of quote asset bought / sold
# _isAdd - true when we are adding quote asset to AMM, false when removing
func swapOutputWithReserves(
  _isAdd: Boolean, 
  _baseAssetAmount: Int,
  _checkMaxPriceImpact: Boolean,
  _quoteAssetReserve: Int,
  _quoteAssetWeight: Int,
  _baseAssetReserve: Int,
  _baseAssetWeight: Int
) = {
  let priceBefore = divd(_quoteAssetReserve.muld(_quoteAssetWeight), _baseAssetReserve.muld(_baseAssetWeight))

  if (_baseAssetAmount == 0) then {
    throw("Invalid base asset amount")
  } else {
    let k = calcInvariant(_quoteAssetReserve, _quoteAssetWeight, _baseAssetReserve, _baseAssetWeight)
    let baseAssetPoolAmountAfter = if (_isAdd) then {
      _baseAssetReserve + _baseAssetAmount 
    } else {
      _baseAssetReserve - _baseAssetAmount
    }

    let quoteAssetAfter = bdivd(k, baseAssetPoolAmountAfter.muld(_baseAssetWeight).toBigInt()).toInt()
    let quoteAssetSold = abs(quoteAssetAfter - _quoteAssetReserve.muld(_quoteAssetWeight))

    let maxPriceImpactValue = maxPriceImpact()

    let (
      quoteAssetReserveAfter1,
      baseAssetReserveAfter1,
      totalPositionSizeAfter1,
      cumulativeNotionalAfter1
    ) = updateReserve(!_isAdd, quoteAssetSold, _baseAssetAmount)

    let marketPrice = divd(quoteAssetSold, _baseAssetAmount)
    let priceDiff = abs(priceBefore - marketPrice)
    let priceImpact = DECIMAL_UNIT - divd(priceBefore, (priceBefore + priceDiff))
    
    if (priceImpact > maxPriceImpactValue && _checkMaxPriceImpact) then {
      throw("Price impact " + priceImpact.toString() + " > max price impact " + maxPriceImpactValue.toString() 
        + " before quote asset: " + _quoteAssetReserve.toString()
        + " before base asset: " + _baseAssetReserve.toString()
        + " base asset amount to exchange: " + _baseAssetAmount.toString()
        + " price before: " + priceBefore.toString()
        + " market price: " + marketPrice.toString()
      )
    } else {
      (
        quoteAssetSold,
        quoteAssetReserveAfter1,
        baseAssetReserveAfter1,
        totalPositionSizeAfter1,
        cumulativeNotionalAfter1,
        totalLongPositionSize()  - if (_isAdd)  then abs(_baseAssetAmount) else 0,
        totalShortPositionSize() - if (!_isAdd) then abs(_baseAssetAmount) else 0,
        priceImpact
      )
    }
  }
}

func swapOutput(
  _isAdd: Boolean, 
  _baseAssetAmount: Int,
  _checkMaxPriceImpact: Boolean
) = {
  swapOutputWithReserves(
    _isAdd,
    _baseAssetAmount,
    _checkMaxPriceImpact,
    qtAstR(),
    qtAstW(),
    bsAstR(),
    bsAstW()
  )
}

# Returns oracle price (Index Price)
func getOracleTwapPrice() = {
  let oracle = addressFromString(this.getStringValue(k_ora)).valueOrErrorMessage("")
  let priceKey = this.getStringValue(k_ora_key)
  let blockKey = this.getStringValue(k_ora_block_key)
  let lastValue = oracle.getInteger(priceKey).valueOrErrorMessage("Can not get oracle price. Oracle: " + oracle.toString() + " key: " + priceKey)
  # let lastOracleBlock = oracle.getIntegerValue(k_ora_block_key)

  # Check that oracle data is not too old
  #if (lastBlock.height <= lastOracleBlock || lastBlock.height - lastOracleBlock > ORACLE_INTERVAL) then {
  #  throw("Invalid oracle data interval")
  #} else {
  lastValue
  #}
}

func requireNotOverSpreadLimit(_quoteAssetReserve: Int, _baseAssetReserve: Int) = {
  let oraclePrice = getOracleTwapPrice()
  let priceAfter = divd(_quoteAssetReserve, _baseAssetReserve)
  let averagePrice = divd(oraclePrice + priceAfter, 2 * DECIMAL_UNIT)
  let absPriceDiff = divd(abs(oraclePrice - priceAfter), averagePrice)
  if (absPriceDiff > maxPriceSpread()) then {
      throw("Price spread " + absPriceDiff.toString() + " > max price spread " + maxPriceSpread().toString())
  } else {
    true
  }
}

func requireNotOverMaxOpenNotional(_longOpenNotional: Int, _shortOpenNotional: Int) = {
  let _maxOpenNotional = maxOpenNotional()
  
  if (_longOpenNotional > _maxOpenNotional) then {
      throw("Long open notional " + _longOpenNotional.toString() + " > max open notional " + _maxOpenNotional.toString())
  } else {
    if (_shortOpenNotional > _maxOpenNotional) then {
      throw("Short open notional " + _shortOpenNotional.toString() + " > max open notional " + _maxOpenNotional.toString())
    } else {
      true
    }
  }
}

# Returns current spot price
func getSpotPrice() = {
  let _quoteAssetReserve = qtAstR()
  let _baseAssetReserve = bsAstR()
  let _qtAstW = qtAstW()
  let _bsAstW = bsAstW()
  divd(_quoteAssetReserve.muld(_qtAstW), _baseAssetReserve.muld(_bsAstW))
}

# Checks if stop price and index price diverge more then spreadLimit
func isOverFluctuationLimit() = {
  let oraclePrice = getOracleTwapPrice()
  let currentPrice = getSpotPrice()
  divd(abs(oraclePrice - currentPrice), oraclePrice) > spreadLimit()
}

func getPositionAdjustedOpenNotional(
  _positionSize: Int, 
  _option: Int,
  _quoteAssetReserve: Int,
  _quoteAssetWeight: Int,
  _baseAssetReserve: Int,
  _baseAssetWeight: Int
) = {
  let positionSizeAbs = abs(_positionSize)
  let isShort = _positionSize < 0
  let positionNotional = if (_option == PNL_OPTION_SPOT) then {
    let (outPositionNotional, x1, x2, x3) = swapOutputWithReserves(
      !isShort,
      positionSizeAbs,
      false,
      _quoteAssetReserve,
      _quoteAssetWeight,
      _baseAssetReserve,
      _baseAssetWeight
    )
    outPositionNotional
  } else {
    muld(positionSizeAbs, getOracleTwapPrice())
  }

  positionNotional
}

# Returns position notional (current value of a position) and
# position profit/loss (delta between initial position notional and current notional)
# Accept calculation option - to use spot or index price
func getPositionNotionalAndUnrealizedPnlByValues(
    _positionSize: Int, 
    _positionOpenNotional: Int, 
    _quoteAssetReserve: Int,
    _quoteAssetWeight: Int,
    _baseAssetReserve: Int,
    _baseAssetWeight: Int,
    _option: Int
  ) = {
    if (_positionSize == 0) then {
      throw("Invalid position size")
    } else {
      let isShort = _positionSize < 0
      let positionNotional = getPositionAdjustedOpenNotional(
        _positionSize,
        _option,
        _quoteAssetReserve,
        _quoteAssetWeight,
        _baseAssetReserve,
        _baseAssetWeight
      )

      let unrealizedPnl = if (isShort) then {
        _positionOpenNotional - positionNotional
      } else {
        positionNotional - _positionOpenNotional
      }
      (
        positionNotional,
        unrealizedPnl
      )
    }
}

# Returns position notional (current value of a position) and
# position profit/loss (delta between initial position notional and current notional)
# Accept calculation option - to use spot or index price
func getPositionNotionalAndUnrealizedPnl(_trader: String, _option: Int) = {
  let (
      positionSize,
      positionMargin,
      positionOpenNotional,
      positionLstUpdCPF
    ) = getPosition(_trader)

    getPositionNotionalAndUnrealizedPnlByValues(
      positionSize,
      positionOpenNotional,
      qtAstR(),
      qtAstW(),
      bsAstR(),
      bsAstW(),
      _option
    )
}

# Computes actual margin ratio
func calcMarginRatio(_remainMargin: Int, _badDebt: Int, _positionNotional: Int) = {
  divd(_remainMargin - _badDebt, _positionNotional)
}

# Computes position margin ratio
# Accept calculation option - to use spot or index price
func getMarginRatioByOption(_trader: String, _option: Int) = {
    let (
      positionSize,
      positionMargin,
      pon,
      positionLstUpdCPF
    ) = getPosition(_trader)

    let (positionNotional, unrealizedPnl) = getPositionNotionalAndUnrealizedPnl(_trader, _option)
    let (remainMargin, badDebt) = calcRemainMarginWithFundingPayment(
        positionSize,
        positionMargin,
        positionLstUpdCPF,
        unrealizedPnl
    )
    calcMarginRatio(remainMargin, badDebt, positionNotional)
}

# Computes position spot margin ratio
func getMarginRatio(_trader: String) = getMarginRatioByOption(_trader, PNL_OPTION_SPOT)

# Computes partial liquidation amount for position
func getPartialLiquidationAmount(_trader: String, _positionSize: Int) = {
    let maximumRatio = vmax(partialLiquidationRatio(), DECIMAL_UNIT - divd(getMarginRatio(_trader), maintenanceMarginRatio()))
    let maxExchangedPositionSize = muld(abs(_positionSize), maximumRatio)
    let swapResult = swapOutput(
      _positionSize > 0,
      maxExchangedPositionSize,
      false
    )
    let maxExchangedQuoteAssetAmount = swapResult._1
    let priceImpact = swapResult._8

    if (priceImpact < maxPriceImpact()) then {
      maxExchangedQuoteAssetAmount
    } else {
      let exchangedPositionSize = muld(abs(_positionSize), partialLiquidationRatio())
      let exchangedQuoteAssetAmount = swapOutput(
        _positionSize > 0,
        exchangedPositionSize,
        false
      )._1
      
      exchangedQuoteAssetAmount
    }
}

# Computes changes to AMM state, resulting in closing trader's position
func internalClosePosition(_trader: String, _checkMaxPriceImpact: Boolean) = {
    let (
      positionSize,
      positionMargin,
      positionOpenNotional,
      positionLstUpdCPF
    ) = getPosition(_trader)

    let unrealizedPnl = getPositionNotionalAndUnrealizedPnl(_trader, PNL_OPTION_SPOT)._2
    let (remainMargin, badDebt) = calcRemainMarginWithFundingPayment(
        positionSize, 
        positionMargin, 
        positionLstUpdCPF,
        unrealizedPnl
    )

    let exchangedPositionSize = -positionSize
    let realizedPnl = unrealizedPnl
    let marginToVault = -remainMargin

    let (
      exchangedQuoteAssetAmount, 
      quoteAssetReserveAfter,
      baseAssetReserveAfter,
      totalPositionSizeAfter,
      cumulativeNotionalAfter,
      totalLongAfter,
      totalShortAfter
    ) = swapOutput(
      positionSize > 0,
      abs(positionSize),
      _checkMaxPriceImpact
    )
    
    let openInterestNotionalAfter = openInterestNotional() - positionOpenNotional
    (
      exchangedPositionSize,
      badDebt,
      realizedPnl,
      marginToVault,
      quoteAssetReserveAfter,
      baseAssetReserveAfter,
      totalPositionSizeAfter,
      cumulativeNotionalAfter,
      openInterestNotionalAfter,
      exchangedQuoteAssetAmount,
      totalLongAfter,
      totalShortAfter,
      openInterestLong() - if (positionSize > 0) then positionOpenNotional else 0,
      openInterestShort() - if (positionSize < 0) then positionOpenNotional else 0
    )
}

# Computes TWAP spot price
func getTwapSpotPrice() = {
  let minuteId = lastBlock.timestamp / 1000 / 60
  let startMinuteId = minuteId - TWAP_INTERVAL
  let listStr = this.getString(k_lastDataStr).valueOrElse("")
  let list = listStr.split(",")
  func filterFn(accumulator: List[Int], next: String) = {
    if (next.parseIntValue() <= startMinuteId) then {
      accumulator :+ next.parseIntValue()
    } else {
      accumulator
    }
  }
  let listF = FOLD<20>(list, [], filterFn)
  let maxIndex = if (listF.size() > 0) then {
    max(listF)
  } else {
    list.getElement(0).parseIntValue()
  }
  let lastMinuteId = this.getInteger(k_lastMinuteId).valueOrElse(0)
  let endLastCumulativePrice = this.getInteger(k_twapDataLastCumulativePrice + "_" + lastMinuteId.toString()).valueOrElse(0)
  let endLastPrice = this.getInteger(k_twapDataLastPrice + "_" + lastMinuteId.toString()).valueOrElse(0)
  let nowCumulativePrice = endLastCumulativePrice + (minuteId - lastMinuteId) * endLastPrice
  
  let startLastCumulativePrice = this.getInteger(k_twapDataLastCumulativePrice + "_" + maxIndex.toString()).valueOrElse(0)
  let startLastPrice = this.getInteger(k_twapDataLastPrice + "_" + maxIndex.toString()).valueOrElse(0)
  let startCumulativePrice = startLastCumulativePrice + (startMinuteId - maxIndex) * startLastPrice
  
  (nowCumulativePrice - startCumulativePrice) / TWAP_INTERVAL
}

func getTerminalAmmState() = {
  let _positionSize = totalPositionSize()
  if (_positionSize == 0) then {
    (qtAstR(), bsAstR())
  } else {
    let direction = _positionSize > 0
    let (
      currentNetMarketValue,
      terminalQuoteAssetReserve,
      terminalBaseAssetReserve
    ) = swapOutput(
      direction,
      abs(_positionSize),
      false
    )

    (terminalQuoteAssetReserve, terminalBaseAssetReserve)
  }
}

func getQuoteAssetWeight(
  baseAssetReserve: Int,
  totalPositionSize: Int,
  quoteAssetReserve: Int, 
  targetPrice: Int
) = {
    let b = baseAssetReserve.toBigInt()
    let sz = totalPositionSize.toBigInt()
    let q = quoteAssetReserve.toBigInt()
    let p = targetPrice.toBigInt()
    
    let bs2 = bpowd(b + sz, (2 * DECIMAL_UNIT).toBigInt())
    let qbs2 = bmuld(q, bs2)
    let ps4 = 4.toBigInt() * p.bmuld(sz)
    let sqr = bsqrtd(qbs2.bmuld(q - ps4))
    let bq = b.bmuld(q)
    let qs = q.bmuld(sz)
    let top = -sqr + bq + qs
    let bot = 2.toBigInt() * q.bmuld(sz)
    let result = top.bdivd(bot)

    result.toInt()
}

func getSyncTerminalPrice(_terminalPrice: Int) = {
  let _positionSize = totalPositionSize()
  if (_positionSize == 0) then {
    let _qtAstR = qtAstR()
    let _bsAstR = bsAstR()
    let newQtAstW = divd(_terminalPrice.muld(_bsAstR), _qtAstR)    
    (
      newQtAstW,
      DECIMAL_UNIT,
      0
    )
  } else {
    let direction = _positionSize > 0
    let currentNetMarketValue = swapOutput(
      direction,
      abs(_positionSize),
      false
    )._1

    let _qtAstR = qtAstR()
    let _bsAstR = bsAstR()
    # Compute new qW and bW
    let newQtAstW = getQuoteAssetWeight(_bsAstR, _positionSize, _qtAstR, _terminalPrice)
    let newBsAstW = DECIMAL_UNIT

    # Compute margin to vault

    let marginToVault = getPositionNotionalAndUnrealizedPnlByValues(
      _positionSize,
      currentNetMarketValue,
      _qtAstR,
      newQtAstW,
      _bsAstR,
      newBsAstW,
      PNL_OPTION_SPOT
    )._2
    
    (
      newQtAstW,
      newBsAstW,
      marginToVault
    )
  }
}

func getFunding() = {
  let underlyingPrice = getOracleTwapPrice()
  let spotTwapPrice = getTwapSpotPrice()
  let premium = spotTwapPrice - underlyingPrice
  
  if (totalShortPositionSize() == 0 || totalLongPositionSize() == 0) then {
    (0, 0)
  } else {
    if (premium < 0) then {
      # underlyingPrice > spotTwapPrice, need to push spotTwapPrice UP, short pays the longs
      # how much to take from shorts this funding period
      let shortPremiumFraction = divd(muld(premium, fundingPeriodDecimal()), ONE_DAY)

      # how much longs will get from shorts total this funding period
      let longPremiumFraction = divd(muld(shortPremiumFraction, totalShortPositionSize()), totalLongPositionSize())
      (shortPremiumFraction, longPremiumFraction)
    } else {
      # underlyingPrice < spotTwapPrice, need to push spotTwapPrice DOWN, longs pays the shorts
      # how much to take from longs this funding period
      let longPremiumFraction = divd(muld(premium, fundingPeriodDecimal()), ONE_DAY)

      # how much shorts will get from longs total this funding period
      let shortPremiumFraction = divd(muld(longPremiumFraction, totalLongPositionSize()), totalShortPositionSize())
      (shortPremiumFraction, longPremiumFraction)
    }
  }
}

func getAdjustedFee(i: Invocation, _baseFeeDiscount: Int) = {
  let baseFeeRaw = fee()
  let baseFee = muld(baseFeeRaw, _baseFeeDiscount)
  let (adjustedFee, burnArtifact) = if (i.payments.size() > 1) then {
      let artifactId = i.payments[1].assetId.valueOrErrorMessage("Invalid attached artifact").toBase58String()
      let artifactKind = strA(nftManagerAddress(), k_token_type.toCompositeKey(artifactId))
      if (artifactKind == FEE_REDUCTION_TOKEN_TYPE) then {
        let reduction = intA(nftManagerAddress(), k_token_param.toCompositeKey(artifactId))
        let adjustedFee = muld(baseFee, reduction)
        (adjustedFee, true)
      } else {
        throw("Invalid attached artifact")
      }
    } else {
      (baseFee, false)
    }
  (adjustedFee, burnArtifact)
}

func updateSettings(
  _initMarginRatio: Int,
  _mmr: Int,
  _liquidationFeeRatio: Int,
  _fundingPeriod: Int,
  _fee: Int,
  _spreadLimit: Int,
  _maxPriceImpact: Int,
  _partialLiquidationRatio: Int,
  _maxPriceSpread: Int,
  _maxOpenNotional: Int
) = {
  [
    IntegerEntry(k_initMarginRatio, _initMarginRatio),
    IntegerEntry(k_maintenanceMarginRatio, _mmr),
    IntegerEntry(k_liquidationFeeRatio, _liquidationFeeRatio),
    IntegerEntry(k_fundingPeriod, _fundingPeriod),
    IntegerEntry(k_fee, _fee),
    IntegerEntry(k_spreadLimit, _spreadLimit),
    IntegerEntry(k_maxPriceImpact, _maxPriceImpact),
    IntegerEntry(k_partialLiquidationRatio, _partialLiquidationRatio),
    IntegerEntry(k_maxPriceSpread, _maxPriceSpread),
    IntegerEntry(k_maxOpenNotional, _maxOpenNotional)
  ]
}

func updateFunding( 
  _nextFundingBlock: Int,
  _latestLongCumulativePremiumFraction: Int,
  _latestShortCumulativePremiumFraction: Int,
  _longFundingRate: Int,
  _shortFundingRate: Int
) = {
  [
    IntegerEntry(k_nextFundingBlock, _nextFundingBlock),
    IntegerEntry(k_latestLongCumulativePremiumFraction, _latestLongCumulativePremiumFraction),
    IntegerEntry(k_latestShortCumulativePremiumFraction, _latestShortCumulativePremiumFraction),
    IntegerEntry(k_longFundingRate, _longFundingRate),
    IntegerEntry(k_shortFundingRate, _shortFundingRate)
  ]
}

func updatePositionAsset(
  _address: String,
  _assetId: String
) = {
  [
    StringEntry(k_positionAsset.toCompositeKey(_address), _assetId)
  ]
}

func updatePosition(
  _address: String,
  _size: Int,
  _margin: Int,
  _openNotional: Int,
  _latestCumulativePremiumFraction: Int
) = {
  [
    IntegerEntry(k_positionSize.toCompositeKey(_address), _size),
    IntegerEntry(k_positionMargin.toCompositeKey(_address), _margin),
    IntegerEntry(k_positionOpenNotional.toCompositeKey(_address), _openNotional),
    IntegerEntry(k_positionLastUpdatedCumulativePremiumFraction.toCompositeKey(_address), _latestCumulativePremiumFraction)
  ]
}

func appendTwap(price: Int) = {
  let minuteId = lastBlock.timestamp / 1000 / 60
  let previousMinuteId = this.getInteger(k_lastMinuteId).valueOrElse(0)
  if (minuteId < previousMinuteId) then {
    throw("TWAP out-of-order")
  } else {
    let lastMinuteId = if (previousMinuteId == 0) then minuteId else previousMinuteId
    if (minuteId > previousMinuteId) then {
      let prevCumulativePrice = this.getInteger(k_twapDataLastCumulativePrice + "_" + previousMinuteId.toString()).valueOrElse(0)
      let prevPrice = this.getInteger(k_twapDataLastPrice + "_" + previousMinuteId.toString()).valueOrElse(price)
      let lastCumulativePrice = prevCumulativePrice + (minuteId - lastMinuteId) * prevPrice

      # Push new minute to list of last minutes with recorded TWAP info
      let list = this.getString(k_lastDataStr).valueOrElse("").strToList().pushToQueue(TWAP_INTERVAL, minuteId.toString())

      # Append new measurement to list of TWAP's
      [
        IntegerEntry(k_twapDataLastCumulativePrice.toCompositeKey(minuteId.toString()), lastCumulativePrice),
        IntegerEntry(k_twapDataLastPrice.toCompositeKey(minuteId.toString()), price),
        IntegerEntry(k_twapDataPreviousMinuteId.toCompositeKey(minuteId.toString()), previousMinuteId),
        IntegerEntry(k_lastMinuteId, minuteId),
        StringEntry(k_lastDataStr, listToStr(list))
      ]
    } else {
      let twapDataPreviousMinuteId = this.getInteger(k_twapDataPreviousMinuteId.toCompositeKey(minuteId.toString())).valueOrElse(0)
      let prevCumulativePrice = this.getInteger(k_twapDataLastCumulativePrice.toCompositeKey(twapDataPreviousMinuteId.toString())).valueOrElse(0)
      let prevPrice = this.getInteger(k_twapDataLastPrice.toCompositeKey(twapDataPreviousMinuteId.toString())).valueOrElse(price)
      let lastCumulativePrice = prevCumulativePrice + (minuteId - twapDataPreviousMinuteId) * prevPrice
      
      # Override LastCumulativePrice and LastPrice to keep latest measurement
      [
        IntegerEntry(k_twapDataLastCumulativePrice.toCompositeKey(minuteId.toString()), lastCumulativePrice),
        IntegerEntry(k_twapDataLastPrice.toCompositeKey(minuteId.toString()), price)
      ]
    }
  }
}

func updateAmmReserves(
  _qtAstR: Int,
  _bsAstR: Int
) = {
  [
    IntegerEntry(k_quoteAssetReserve, _qtAstR),
    IntegerEntry(k_baseAssetReserve, _bsAstR)
  ]
}

func updateAmmWeights(
  _qtAstW: Int,
  _bsAstW: Int
) = {
  [
    IntegerEntry(k_quoteAssetWeight, _qtAstW),
    IntegerEntry(k_baseAssetWeight, _bsAstW)
  ]
}

func updateAmm(
  _qtAstR: Int,
  _bsAstR: Int,
  _totalPositionSizeAfter: Int,
  _cumulativeNotionalAfter: Int,
  _openInterestNotional: Int,
  _totalLongPositionSize: Int,
  _totalShortPositionSize: Int,
  _totalLongOpenNotional: Int,
  _totalShortOpenNotional: Int
) = {
  let _qtAstW = qtAstW()
  let _bsAstW = bsAstW()
  if (_totalLongPositionSize - _totalShortPositionSize != _totalPositionSizeAfter) then {
    throw("Invalid AMM state data: " + _totalLongPositionSize.toString() + " +  " + _totalShortPositionSize.toString() + " != " + _totalPositionSizeAfter.toString())
  } else {
    updateAmmReserves(_qtAstR, _bsAstR)
    ++
    [
      IntegerEntry(k_totalPositionSize, _totalPositionSizeAfter),
      IntegerEntry(k_cumulativeNotional, _cumulativeNotionalAfter),
      IntegerEntry(k_openInterestNotional, _openInterestNotional),
      IntegerEntry(k_totalLongPositionSize, _totalLongPositionSize),
      IntegerEntry(k_totalShortPositionSize, _totalShortPositionSize),
      IntegerEntry(k_openInterestLong, _totalLongOpenNotional),
      IntegerEntry(k_openInterestShort, _totalShortOpenNotional)
    ] ++ appendTwap(divd(_qtAstR.muld(_qtAstW), _bsAstR.muld(_bsAstW)))
  }
}

func deletePosition(
  _address: String
) = {
  [
    DeleteEntry(k_positionSize.toCompositeKey(_address)),
    DeleteEntry(k_positionMargin.toCompositeKey(_address)),
    DeleteEntry(k_positionOpenNotional.toCompositeKey(_address)),
    DeleteEntry(k_positionLastUpdatedCumulativePremiumFraction.toCompositeKey(_address)),
    DeleteEntry(k_positionAsset.toCompositeKey(_address)),
    IntegerEntry(k_positionClosedDate.toCompositeKey(_address), lastBlock.timestamp)
  ]
}

func withdraw(
  _address: Address,
  _amount: Int
) = {
  let balance = assetBalance(this, quoteAsset())
  if (balance < _amount) then {
    throw("Unable to withdraw " + _amount.toString() + " from contract balance " + balance.toString())
  } else {
    [
      ScriptTransfer(_address, _amount, quoteAsset())
    ]
  }
}

func updateBalance(i: Int) = {
  if (i < 0) then {
    throw("Balance")
  } else {
    [
      IntegerEntry(k_balance, i)
    ]
  }
}

func transferFee(i: Int) = {
  [
    ScriptTransfer(stakingAddress(), i, quoteAsset())
  ]
}

func doBurnArtifact(_burnArtifact: Boolean, i: Invocation) = {
  if (_burnArtifact) then {
    [
      Burn(i.payments[1].assetId.valueOrErrorMessage("Invalid artifact"), 1)
    ]
  } else {
    []
  }
}

func isSameAssetOrNoPosition(_trader: String, _assetId: String) = {
    let oldPositionSize = getPosition(_trader)._1
    if (oldPositionSize == 0) then {
      true
    } else {
      getPositionAsset(_trader) == _assetId
    }
}

func isSameAsset(_trader: String, _assetId: String) = {
    getPositionAsset(_trader) == _assetId
}

func getBorrowedByTraderInMarketKey(_amm: String, _assetId: String, _trader: String) = {
  k_trader_market_asset_collateral + "_" + _amm + "_" + _assetId + "_" + _trader
}

func getBorrowedByTrader(_trader: String) = {
  let positionAsset = getPositionAsset(_trader)
  if (positionAsset == quoteAsset().toBase58String()) then {
    (0, positionAsset)
  } else {
    let key = getBorrowedByTraderInMarketKey(this.toString(), positionAsset, _trader)
    let borrow = collateralAddress().getInteger(key).valueOrElse(0)
    (borrow, positionAsset)
  }
}


##### Callable functions #####

@Callable(i)
func pause() = {
  if (i.caller != adminAddress()) then {
    throw("Invalid togglePause params")
  } else {
    [
      BooleanEntry(k_paused, true)
    ]
  }
}

@Callable(i)
func unpause() = {
  if (i.caller != adminAddress()) then {
    throw("Invalid togglePause params")
  } else {
    [
      BooleanEntry(k_paused, false)
    ]
  }
}

@Callable(i)
func addLiquidity(_quoteAssetAmount: Int) = {
  if (
    i.caller != adminAddress()
    || _quoteAssetAmount <= 0
  ) then {
    throw("Invalid addLiquidity params")
  } else {
    let _qtAstR = qtAstR()
    let _bsAstR = bsAstR()
    let _qtAstW = qtAstW()
    let _bsAstW = bsAstW()
    let price = divd(_qtAstR.muld(_qtAstW), _bsAstR.muld(_bsAstW))
    let baseAssetAmountToAdd = divd(_quoteAssetAmount, price)

    let qtAstRAfter = _qtAstR + _quoteAssetAmount
    let bsAstRAfter = _bsAstR + baseAssetAmountToAdd  

    updateAmmReserves(qtAstRAfter, bsAstRAfter)
  }
}

@Callable(i)
func removeLiquidity(_quoteAssetAmount: Int) = {
  if (
    i.caller != adminAddress()
    || _quoteAssetAmount <= 0
  ) then {
    throw("Invalid removeLiquidity params")
  } else {
    let _qtAstR = qtAstR()
    let _bsAstR = bsAstR()
    let _qtAstW = qtAstW()
    let _bsAstW = bsAstW()
    let price = divd(_qtAstR.muld(_qtAstW), _bsAstR.muld(_bsAstW))
    let baseAssetAmountToRemove = divd(_quoteAssetAmount, price)

    let qtAstRAfter = _qtAstR - _quoteAssetAmount
    let bsAstRAfter = _bsAstR - baseAssetAmountToRemove

    updateAmmReserves(qtAstRAfter, bsAstRAfter)
  }
}

@Callable(i)
func changeSettings(
  _initMarginRatio: Int,
  _mmr: Int,
  _liquidationFeeRatio: Int,
  _fundingPeriod: Int,
  _fee: Int,
  _spreadLimit: Int,
  _maxPriceImpact: Int,
  _partialLiquidationRatio: Int,
  _maxPriceSpread: Int,
  _maxOpenNotional: Int
) = {
  if (i.caller != adminAddress()) then {
    throw("Invalid changeSettings params")
  } else {
    updateSettings(
      _initMarginRatio, 
      _mmr, 
      _liquidationFeeRatio, 
      _fundingPeriod, 
      _fee, 
      _spreadLimit, 
      _maxPriceImpact,
      _partialLiquidationRatio,
      _maxPriceSpread,
      _maxOpenNotional
    )
  }
}

@Callable(i)
func initialize(
  _qtAstR: Int,
  _bsAstR: Int,
  _fundingPeriod: Int,
  _initMarginRatio: Int,
  _mmr: Int,
  _liquidationFeeRatio: Int,
  _fee: Int,
  _oracle: String,
  _oracleKey: String,
  _coordinator: String,
  _spreadLimit: Int,
  _maxPriceImpact: Int,
  _partialLiquidationRatio: Int,
  _maxPriceSpread: Int,
  _maxOpenNotional: Int
) = {
  if (
    _qtAstR <= 0
    || _bsAstR <= 0
    || _fundingPeriod <= 0
    || _initMarginRatio <= 0
    || _mmr <= 0
    || _liquidationFeeRatio <= 0
    || _fee <= 0
    || _spreadLimit <= 0
    || _maxPriceImpact <= 0
    || _partialLiquidationRatio <= 0
    || _maxPriceSpread <= 0
    || _maxOpenNotional <= 0
    || initialized()
  ) then {
    throw("Invalid initialize parameters")
  } else {
    updateAmm(_qtAstR, _bsAstR, 0, 0, 0, 0, 0, 0, 0)
    ++
    updateSettings(
      _initMarginRatio, 
      _mmr, 
      _liquidationFeeRatio, 
      _fundingPeriod, 
      _fee, 
      _spreadLimit, 
      _maxPriceImpact,
      _partialLiquidationRatio,
      _maxPriceSpread,
      _maxOpenNotional
    )
    ++
    updateFunding(
      lastBlock.timestamp + _fundingPeriod,
      0,
      0,
      0,
      0
    )
    ++
    updateBalance(0)
    ++
    [
      BooleanEntry(k_initialized, true),
      StringEntry(k_ora, _oracle),
      StringEntry(k_ora_key, _oracleKey),
      StringEntry(k_coordinatorAddress, _coordinator)
    ]
  }
}

@Callable(i)
func decreasePosition(
  _amount: Int,
  _leverage: Int,
  _minBaseAssetAmount: Int
) = {
  strict sync = invoke(this, "syncTerminalPriceToOracle", [], [])

  if (
    _amount <= 0
    || !initialized()
    || !requireMoreMarginRatio(divd(DECIMAL_UNIT, _leverage), initMarginRatio(), true)
    || !requireOpenPosition(i.caller.toString())
    || paused()
  ) then {
    throw("Invalid decreasePosition parameters")
  } else {
    let (
      oldPositionSize,
      oldPositionMargin,
      oldPositionOpenNotional,
      oldPositionLstUpdCPF
    ) = getPosition(i.caller.toString())

    let _direction = if (oldPositionSize > 0) then DIR_SHORT else DIR_LONG
    let isAdd = _direction == DIR_LONG
    
    let openNotional = muld(_amount, _leverage)
    let (oldPositionNotional, unrealizedPnl) = getPositionNotionalAndUnrealizedPnl(i.caller.toString(), PNL_OPTION_SPOT)

    let (
      newPositionSize,
      newPositionRemainMargin,
      newPositionOpenNotional,
      newPositionLatestCPF,
      baseAssetReserveAfter,
      quoteAssetReserveAfter,
      totalPositionSizeAfter,
      cumulativeNotionalAfter,
      openInterestNotionalAfter,
      totalLongAfter,
      totalShortAfter,
      totalLongOpenInterestAfter,
      totalShortOpenInterestAfter
    ) = if (oldPositionNotional > openNotional) then {
      let ( 
          exchangedPositionSize, 
          quoteAssetReserveAfter, 
          baseAssetReserveAfter,
          totalPositionSizeAfter,
          cumulativeNotionalAfter
        ) = swapInput(isAdd, openNotional)
        let exchangedPositionSizeAbs = abs(exchangedPositionSize)

        if (_minBaseAssetAmount != 0 && exchangedPositionSizeAbs < _minBaseAssetAmount) then {
            throw("Too little base asset exchanged, got " + exchangedPositionSizeAbs.toString() + " expected " + _minBaseAssetAmount.toString())
        } else {
          let realizedPnl = divd(muld(unrealizedPnl, exchangedPositionSizeAbs), abs(oldPositionSize))
          let (remainMargin, badDebt, fundingPayment) = 
            calcRemainMarginWithFundingPayment(
                oldPositionSize, 
                oldPositionMargin, 
                oldPositionLstUpdCPF, 
                realizedPnl
            )
          let exchangedQuoteAssetAmount = openNotional
          let unrealizedPnlAfter = unrealizedPnl - realizedPnl
          let remainOpenNotional = if (oldPositionSize > 0) then {
            oldPositionNotional - exchangedQuoteAssetAmount - unrealizedPnlAfter
          } else {
            unrealizedPnlAfter + oldPositionNotional - exchangedQuoteAssetAmount
          }

          let newPositionSize = oldPositionSize + exchangedPositionSize
          (
            newPositionSize, # positionSize
            remainMargin, # remainMargin
            abs(remainOpenNotional), # pon
            latestCumulativePremiumFraction(newPositionSize), # latestCPF
            baseAssetReserveAfter, # baseAssetReserveAfter
            quoteAssetReserveAfter, # quoteAssetReserveAfter
            totalPositionSizeAfter, # totalPositionSizeAfter
            cumulativeNotionalAfter, # cumulativeNotionalAfter
            openInterestNotional() - openNotional, # openInterestNotionalAfter
            totalLongPositionSize() - if (newPositionSize > 0) then abs(exchangedPositionSize) else 0,
            totalShortPositionSize() - if (newPositionSize < 0) then abs(exchangedPositionSize) else 0,
            openInterestLong() - if (newPositionSize > 0) then openNotional else 0,
            openInterestShort() - if (newPositionSize < 0) then openNotional else 0
          )
        }
    } else {
      throw("Close position first")
    }

    strict notifyNotional = invoke(
      minerAddress(),
      "notifyNotional",
      [i.caller.toString(), newPositionOpenNotional],
      []
    )
    
    updatePosition(
      i.caller.toString(),
      newPositionSize,
      newPositionRemainMargin,
      newPositionOpenNotional,
      newPositionLatestCPF
    ) 
    ++
    updateAmm(
      quoteAssetReserveAfter,
      baseAssetReserveAfter,
      totalPositionSizeAfter,
      cumulativeNotionalAfter,
      openInterestNotionalAfter,
      totalLongAfter,
      totalShortAfter,
      totalLongOpenInterestAfter,
      totalShortOpenInterestAfter
    )
  }
}

@Callable(i)
func increasePosition(
  _direction: Int,
  _leverage: Int,
  _minBaseAssetAmount: Int,
  _refLink: String
) = {
  strict sync = invoke(this, "syncTerminalPriceToOracle", [], [])

  let _trader = i.caller.toString()
  let _rawAmount = i.payments[0].amount
  let _assetId = i.payments[0].assetId
  let _assetIdStr = _assetId.value().toBase58String()
  let isQuoteAsset = _assetId == quoteAsset()
  let isCollateralAsset = isWhitelistAsset(_assetIdStr)
  if (
    (_direction != DIR_LONG && _direction != DIR_SHORT)
    || _rawAmount <= 0
    || !initialized()
    || (!isQuoteAsset && !isCollateralAsset)
    || !isSameAssetOrNoPosition(_trader, _assetIdStr)
    || !requireMoreMarginRatio(divd(DECIMAL_UNIT, _leverage), initMarginRatio(), true)
    || paused()
  ) then {
    throw("Invalid increasePosition parameters")
  } else {
    strict doGetFeeDiscount = invoke(
      minerAddress(),
      "computeFeeDiscount",
      [_trader],
      []
    )

    let feeDiscount = match(doGetFeeDiscount) {
      case x: Int => x
      case _ => throw("Invalid computeFeeDiscount result")
    }

    let (adjustedFee, burnArtifact) = getAdjustedFee(i, feeDiscount)
    let rawFeeAmount = muld(_rawAmount, adjustedFee)
    let _amount = _rawAmount - rawFeeAmount

    # If we are operating with non-USDN collateral, borrow _amount
    # of USDN to proceed and send rawFeeAmount of non-USDN collateral
    # to exchange to USDN. 
    #
    strict distributeFeeAmount = if (isCollateralAsset) then {
      strict doBorrow = invoke(
        collateralAddress(),
        "borrow",
        [_trader],
        [AttachedPayment(_assetId, _amount)]
      )

      strict balanceBefore = assetBalance(this, quoteAsset())
      strict doSwap = invoke(
        swapAddress(),
        "swap",
        [toBase58String(quoteAsset()), 0], # Want Quote Asset
        [AttachedPayment(_assetId, rawFeeAmount)] # In exchange for Provided Asset
      )
      strict balanceAfter = assetBalance(this, quoteAsset())
      strict exchangedAmount = balanceAfter - balanceBefore

      exchangedAmount
    } else {
      rawFeeAmount
    }

    strict referrerFeeAny = invoke(
      referralAddress(),
      "acceptPaymentWithLink",
      [_trader, _refLink],
      [AttachedPayment(quoteAsset(), distributeFeeAmount)]
    )

    let referrerFee = match(referrerFeeAny) {
      case x: Int => x
      case _ => throw("Invalid referrerFee")
    }

    let feeAmount = distributeFeeAmount - referrerFee
    let (
      oldPositionSize,
      oldPositionMargin,
      oldPositionOpenNotional,
      oldPositionLstUpdCPF
    ) = getPosition(_trader)
    let isNewPosition = oldPositionSize == 0
    let isSameDirection = if (oldPositionSize > 0) then {
      _direction == DIR_LONG
    } else {
      _direction == DIR_SHORT
    }
    let expandExisting = !isNewPosition && isSameDirection
    let isAdd = _direction == DIR_LONG
    
    let (
      newPositionSize,
      newPositionRemainMargin,
      newPositionOpenNotional,
      newPositionLatestCPF,
      baseAssetReserveAfter,
      quoteAssetReserveAfter,
      totalPositionSizeAfter,
      cumulativeNotionalAfter,
      openInterestNotionalAfter,
      totalLongAfter,
      totalShortAfter,
      totalLongOpenInterestAfter,
      totalShortOpenInterestAfter
    ) = if (isNewPosition || expandExisting) then {
      let openNotional = muld(_amount, _leverage)
      let ( 
        amountBaseAssetBought,
        quoteAssetReserveAfter, 
        baseAssetReserveAfter,
        totalPositionSizeAfter,
        cumulativeNotionalAfter
      ) = swapInput(isAdd, openNotional)
       
      if (_minBaseAssetAmount != 0 && abs(amountBaseAssetBought) < _minBaseAssetAmount) then {
         throw("Limit error: " + abs(amountBaseAssetBought).toString() + " < " + _minBaseAssetAmount.toString())
       } else {
        let newPositionSize = oldPositionSize + amountBaseAssetBought
        let totalLongOpenInterestAfter = openInterestLong() + if (newPositionSize > 0) then openNotional else 0
        let totalShortOpenInterestAfter = openInterestShort() + if (newPositionSize < 0) then openNotional else 0

        let increaseMarginRequirement = divd(openNotional, _leverage)
        let (remainMargin, x1, x2) =
          calcRemainMarginWithFundingPayment(
                oldPositionSize, 
                oldPositionMargin, 
                oldPositionLstUpdCPF, 
                increaseMarginRequirement
            )
        if (!requireNotOverSpreadLimit(quoteAssetReserveAfter, baseAssetReserveAfter)) then {
          throw("Over max spread limit")
        } else {
          if (!requireNotOverMaxOpenNotional(totalLongOpenInterestAfter, totalShortOpenInterestAfter)) then {
            throw("Over max open notional")
          } else {
            (
              newPositionSize, # positionSize
              remainMargin, # remainMargin
              oldPositionOpenNotional + openNotional, # positionOpenNotional
              latestCumulativePremiumFraction(newPositionSize), # latestCPF
              baseAssetReserveAfter, # baseAssetReserveAfter
              quoteAssetReserveAfter, # quoteAssetReserveAfter
              totalPositionSizeAfter, # totalPositionSizeAfter
              cumulativeNotionalAfter, # cumulativeNotionalAfter
              openInterestNotional() + openNotional, # openInterestNotionalAfter
              totalLongPositionSize() + if (newPositionSize > 0) then abs(amountBaseAssetBought) else 0,
              totalShortPositionSize() + if (newPositionSize < 0) then abs(amountBaseAssetBought) else 0,
              totalLongOpenInterestAfter,
              totalShortOpenInterestAfter
            )
          }
        }
       }
    } else {
      let openNotional = muld(_amount, _leverage)
      let (oldPositionNotional, unrealizedPnl) = getPositionNotionalAndUnrealizedPnl(i.caller.toString(), PNL_OPTION_SPOT)
      if (oldPositionNotional > openNotional) then {
        throw("Use decreasePosition to decrease position size")
      } else {
        throw("Close position first")
      }
    }

    let feeToStakers = feeAmount / 2
    let feeToInsurance = feeAmount - feeToStakers
    
    strict stake = invoke(
      vaultAddress(),
      "addLocked",
      [],
      [AttachedPayment(quoteAsset(), _amount)]
    )

    strict depositInsurance = invoke(
      vaultAddress(),
      "addFree",
      [],
      [AttachedPayment(quoteAsset(), feeToInsurance)]
    )

    strict notifyFee = invoke(
      minerAddress(),
      "notifyFees",
      [_trader, feeAmount],
      []
    )

    strict notifyNotional = invoke(
      minerAddress(),
      "notifyNotional",
      [_trader, newPositionOpenNotional],
      []
    )
    
    updatePosition(
      _trader,
      newPositionSize,
      newPositionRemainMargin,
      newPositionOpenNotional,
      newPositionLatestCPF
    ) 
    ++
    updatePositionAsset(_trader, _assetIdStr)
    ++
    updateAmm(
      quoteAssetReserveAfter,
      baseAssetReserveAfter,
      totalPositionSizeAfter,
      cumulativeNotionalAfter,
      openInterestNotionalAfter,
      totalLongAfter,
      totalShortAfter,
      totalLongOpenInterestAfter,
      totalShortOpenInterestAfter
    )
    ++
    transferFee(feeToStakers)
    ++
    updateBalance(cbalance() + _amount)
    ++
    doBurnArtifact(burnArtifact, i)
  }
}

@Callable(i)
func addMargin() = {
  strict sync = invoke(this, "syncTerminalPriceToOracle", [], [])

  let _trader = i.caller.toString()
  let _rawAmount = i.payments[0].amount
  let _assetId = i.payments[0].assetId
  let _assetIdStr = _assetId.value().toBase58String()
  let isQuoteAsset = _assetId == quoteAsset()
  let isCollateralAsset = isWhitelistAsset(_assetIdStr)
  if (
    (!isQuoteAsset && !isCollateralAsset)
    || !requireOpenPosition(i.caller.toString())
    || !isSameAsset(_trader, _assetIdStr)
    || !initialized()
    || paused()
  ) then {
    throw("Invalid addMargin parameters")
  } else {
    strict doGetFeeDiscount = invoke(
      minerAddress(),
      "computeFeeDiscount",
      [_trader],
      []
    )

    let feeDiscount = match(doGetFeeDiscount) {
      case x: Int => x
      case _ => throw("Invalid computeFeeDiscount result")
    }

    let (adjustedFee, burnArtifact) = getAdjustedFee(i, feeDiscount)
    let rawFeeAmount = muld(_rawAmount, adjustedFee)
    let _amount = _rawAmount - rawFeeAmount

    # If we are operating with non-USDN collateral, borrow _amount
    # of USDN to proceed and send rawFeeAmount of non-USDN collateral
    # to exchange to USDN. 
    #
    strict distributeFeeAmount = if (isCollateralAsset) then {
      strict doBorrow = invoke(
        collateralAddress(),
        "borrow",
        [_trader],
        [AttachedPayment(_assetId, _amount)]
      )

      strict balanceBefore = assetBalance(this, quoteAsset())
      strict doSwap = invoke(
        swapAddress(),
        "swap",
        [toBase58String(quoteAsset()), 0], # Want Quote Asset
        [AttachedPayment(_assetId, rawFeeAmount)] # In exchange for Provided Asset
      )
      strict balanceAfter = assetBalance(this, quoteAsset())
      strict exchangedAmount = balanceAfter - balanceBefore

      exchangedAmount
    } else {
      rawFeeAmount
    }

    strict referrerFeeAny = invoke(
      referralAddress(),
      "acceptPayment",
      [_trader],
      [AttachedPayment(quoteAsset(), distributeFeeAmount)]
    )

    let referrerFee = match(referrerFeeAny) {
      case x: Int => x
      case _ => throw("Invalid referrerFee")
    }

    let feeAmount = distributeFeeAmount - referrerFee

    let (
      oldPositionSize,
      oldPositionMargin,
      oldPositionOpenNotional,
      oldPositionLstUpdCPF
    ) = getPosition(_trader)

    let feeToStakers = feeAmount / 2
    let feeToInsurance = feeAmount - feeToStakers
  
    strict stake = invoke(
      vaultAddress(),
      "addLocked",
      [],
      [AttachedPayment(quoteAsset(), _amount)]
    )

    strict depositInsurance = invoke(
      vaultAddress(),
      "addFree",
      [],
      [AttachedPayment(quoteAsset(), feeToInsurance)]
    )

    strict notifyFee = invoke(
      minerAddress(),
      "notifyFees",
      [_trader, feeAmount],
      []
    )

    updatePosition(
      _trader,
      oldPositionSize,
      oldPositionMargin + _amount,
      oldPositionOpenNotional,
      oldPositionLstUpdCPF
    )
    ++
    transferFee(feeToStakers)
    ++
    updateBalance(cbalance() + _amount)
    ++
    doBurnArtifact(burnArtifact, i)
  }
}

@Callable(i)
func removeMargin(
  _amount: Int
) = {
  strict sync = invoke(this, "syncTerminalPriceToOracle", [], [])

  let _trader = i.caller.toString()
  if (
    _amount <= 0
    || !requireOpenPosition(_trader)
    || !initialized()
    || paused()
  ) then {
    throw("Invalid removeMargin parameters")
  } else {
    let (
      oldPositionSize,
      oldPositionMargin,
      oldPositionOpenNotional,
      oldPositionLstUpdCPF
    ) = getPosition(_trader)

    let marginDelta = -_amount
    let (remainMargin, badDebt) =
      calcRemainMarginWithFundingPayment(
        oldPositionSize,
        oldPositionMargin,
        oldPositionLstUpdCPF,
        marginDelta
    )
    if (badDebt != 0) then {
      throw("Invalid removed margin amount")
    } else {
      let marginRatio = calcMarginRatio(remainMargin, badDebt, oldPositionOpenNotional)
      if (!requireMoreMarginRatio(marginRatio, initMarginRatio(), true)) then {
        throw("Too much margin removed: " + marginRatio.toString() + " < " + initMarginRatio().toString())
      } else {
        let quoteAssetStr = quoteAsset().toBase58String()
        let (borrowed, assetId) = getBorrowedByTrader(_trader)
        let toRepay = if (_amount > borrowed) then borrowed else _amount
        let toWithdraw = if (_amount < borrowed) then 0 else _amount - borrowed
        let finalBorrow = borrowed - toRepay
        let switchPositionToQuote = if (finalBorrow > 0) then {
          []
        } else {
          updatePositionAsset(_trader, quoteAssetStr)
        }

        strict doSanityCheck = if (toRepay + toWithdraw != _amount) then {
          throw("toRepay=" + toRepay.toString() + " + toWithdraw=" + toWithdraw.toString() + " != " + _amount.toString())
        } else {
          []
        }
        
        strict doUnstake = invoke(
          vaultAddress(),
          "withdrawLocked",
          [_amount], # We need to withdraw from manager amount to repay + to withdraw
          []
        )

        # strict repayDebug = throw("borrowed=" + borrowed.toString() + "toRepay=" + toRepay.toString() + "toWithdraw=" + toWithdraw.toString() + "finalBorrow=" + finalBorrow.toString() + "assetId=" + assetId)

        strict returnCollateralAction = if (toRepay > 0) then {
          strict doRepay = invoke(
            collateralAddress(),
            "repay",
            [_trader, assetId],
            [AttachedPayment(quoteAsset(), toRepay)]
          )          

          [
            ScriptTransfer(i.caller, toRepay, fromBase58String(assetId))
          ]
        } else {
          []
        }
        
        updatePosition(
          _trader,
          oldPositionSize,
          remainMargin,
          oldPositionOpenNotional,
          latestCumulativePremiumFraction(oldPositionSize)
        )
        ++
        (if (toWithdraw > 0) then withdraw(i.caller, toWithdraw) else [])
        ++
        updateBalance(cbalance() - _amount)
        ++
        switchPositionToQuote
        ++
        returnCollateralAction
      }
    }
  }
}

@Callable(i)
func closePosition() = {
  strict sync = invoke(this, "syncTerminalPriceToOracle", [], [])

  let _trader = getActualCaller(i)
  let _traderAddress = addressFromString(_trader).valueOrErrorMessage("Invalid caller")
    if (
      !requireOpenPosition(_trader)
      || !initialized()
      || paused()
  ) then {
    throw("Invalid closePosition parameters")
  } else {
    let (
          x1,
          positionBadDebt,
          realizedPnl,
          marginToVault,
          quoteAssetReserveAfter,
          baseAssetReserveAfter,
          totalPositionSizeAfter,
          cumulativeNotionalAfter,
          openInterestNotionalAfter,
          x2,
          totalLongAfter,
          totalShortAfter,
          totalLongOpenInterestAfter,
          totalShortOpenInterestAfter
    ) = internalClosePosition(_trader, true)

    if (positionBadDebt > 0) then {
      throw("Unable to close position with bad debt")
    } else {
      let withdrawAmount = abs(marginToVault)

      let ammBalance = cbalance() - withdrawAmount
      # strict debug = throw("cbalance=" + cbalance().toString() + " withdrawAmount=" + withdrawAmount.toString())
      let (ammNewBalance, x11) = if (ammBalance < 0) then {
        (0, abs(ammBalance))
      } else {
        (ammBalance, 0)
      }

      strict unstake = invoke(
        vaultAddress(),
        "withdrawLocked",
        [withdrawAmount],
        []
      )

      # As we are closing a position - we need to repay all the debt
      #
      let (borrowed, assetId) = getBorrowedByTrader(_trader)       

      strict (sendCollateralAction, quoteWithdrawAmount) = if (borrowed > 0) then {
        if (withdrawAmount >= borrowed) then {
          strict doRepay = invoke(
            collateralAddress(),
            "repay",
            [_trader, assetId],
            [AttachedPayment(quoteAsset(), borrowed)]
          )   
          
          ([
            ScriptTransfer(_traderAddress, borrowed, fromBase58String(assetId))
          ], withdrawAmount - borrowed)
        } else {
          strict realizeAndClose = invoke(
            collateralAddress(),
            "realizePartiallyAndClose",
            [_trader, assetId],
            [AttachedPayment(quoteAsset(), withdrawAmount)]
          )
          
          ([
            ScriptTransfer(_traderAddress, withdrawAmount, fromBase58String(assetId))
          ], 0) # No extra USDN during settlement
        }
      } else {
        ([], withdrawAmount)
      }

      strict notifyNotional = invoke(
        minerAddress(),
        "notifyNotional",
        [_trader, 0],
        []
      )
      
      deletePosition(_trader) 
      ++ 
      updateAmm(
        quoteAssetReserveAfter,
        baseAssetReserveAfter,
        totalPositionSizeAfter,
        cumulativeNotionalAfter,
        openInterestNotionalAfter,
        totalLongAfter,
        totalShortAfter,
        totalLongOpenInterestAfter,
        totalShortOpenInterestAfter
      )
      ++
      (if (quoteWithdrawAmount > 0) then withdraw(_traderAddress, quoteWithdrawAmount) else [])
      ++
      updateBalance(ammNewBalance)
      ++
      sendCollateralAction
    }
  }
}

@Callable(i)
func liquidate(_trader: String) = {
  strict sync = invoke(this, "syncTerminalPriceToOracle", [], [])
  # If market (future) price and index price diverge a lot, use index price to compute
  # liquidation margin. That provides additional safety layer for traders
  #
  let spotMarginRatio = getMarginRatioByOption(_trader, PNL_OPTION_SPOT)
  let marginRatio = if (isOverFluctuationLimit()) then {
    let oracleMarginRatio = getMarginRatioByOption(_trader, PNL_OPTION_ORACLE)
    vmax(spotMarginRatio, oracleMarginRatio)
  } else {
    spotMarginRatio
  }
  if (
    !requireMoreMarginRatio(marginRatio, maintenanceMarginRatio(), false)
    || !requireOpenPosition(_trader)
    || !initialized()
    || paused()
  ) then {
    throw("Unable to liquidate")
  } else {
    if (
      # This check guarantees no bad debt, because bad debt can happen only when
      # spotMarginRatio < 0, and liquidationFeeRatio > 0
      spotMarginRatio > liquidationFeeRatio()
      && partialLiquidationRatio() > 0
      && partialLiquidationRatio() < DECIMAL_UNIT
    ) then {
      # Liquidate position partially by basically doing decrease position
      let (
        oldPositionSize,
        oldPositionMargin,
        oldPositionOpenNotional,
        oldPositionLstUpdCPF
      ) = getPosition(_trader)

      let _direction = if (oldPositionSize > 0) then DIR_SHORT else DIR_LONG
      let isAdd = _direction == DIR_LONG
      
      let exchangedQuoteAssetAmount = getPartialLiquidationAmount(_trader, oldPositionSize)
      let (oldPositionNotional, unrealizedPnl) = getPositionNotionalAndUnrealizedPnl(_trader, PNL_OPTION_SPOT)

      let ( 
          exchangedPositionSize, 
          quoteAssetReserveAfter, 
          baseAssetReserveAfter,
          totalPositionSizeAfter,
          cumulativeNotionalAfter
        ) = swapInput(isAdd, exchangedQuoteAssetAmount)
      
      let liquidationRatio = divd(abs(exchangedPositionSize), abs(oldPositionSize))
      # Realize a certain percent of position loss 
      # Bad debt is always 0 here, because of positive margin ratio)
      #
      let realizedPnl = muld(unrealizedPnl, liquidationRatio)
      let (remainMargin, badDebt, fundingPayment) = 
          calcRemainMarginWithFundingPayment(
              oldPositionSize, 
              oldPositionMargin, 
              oldPositionLstUpdCPF, 
              realizedPnl
          )
      let unrealizedPnlAfter = unrealizedPnl - realizedPnl
      let remainOpenNotional = if (oldPositionSize > 0) then {
        oldPositionNotional - exchangedQuoteAssetAmount - unrealizedPnlAfter
      } else {
        unrealizedPnlAfter + oldPositionNotional - exchangedQuoteAssetAmount
      }

      # Liquidator get a certain (liquidationFeeRatio) percentage from a total position
      #
      let liquidationPenalty = muld(exchangedQuoteAssetAmount, liquidationFeeRatio())
      let feeToLiquidator = liquidationPenalty / 2
      let feeToInsurance = liquidationPenalty - feeToLiquidator

      let newPositionMargin = remainMargin - liquidationPenalty
      let newPositionSize = oldPositionSize + exchangedPositionSize
      let newPositionOpenNotional = abs(remainOpenNotional)
      let newPositionLstUpdCPF = latestCumulativePremiumFraction(newPositionSize)

      let openInterestNotionalAfter = openInterestNotional() - exchangedQuoteAssetAmount

      # Liquidating a position can incur bad debt. If AMM does not have enough funds to cover up bad debt
      # use Insurance Fund to cover it up
      let ammBalance = cbalance() - liquidationPenalty
      let (newAmmBalance, x11) = if (ammBalance < 0) then {
        (0, abs(ammBalance))
      } else {
        (ammBalance, 0)
      }

      let (borrowed, assetId) = getBorrowedByTrader(_trader) 

      strict doLiquidateCollateral = if (borrowed > 0) then {
        let collateralToSell = muld(borrowed, liquidationRatio)
        
        strict realizeAndClose = invoke(
          collateralAddress(),
          "realizePartially",
          [_trader, assetId, collateralToSell],
          [] # Full liquidation of remain collateral
        )
        []
      } else {
        []
      }

      strict unstake = invoke(
        vaultAddress(),
        "withdrawLocked",
        [liquidationPenalty],
        []
      )

      strict depositInsurance = invoke(
        vaultAddress(),
        "addFree",
        [],
        [AttachedPayment(quoteAsset(), feeToInsurance)]
      )

      strict notifyNotional = invoke(
        minerAddress(),
        "notifyNotional",
        [_trader, newPositionOpenNotional],
        []
      )

      updatePosition(
        _trader,
        newPositionSize,
        newPositionMargin,
        newPositionOpenNotional,
        newPositionLstUpdCPF
      ) 
      ++ 
      updateAmm(
        quoteAssetReserveAfter,
        baseAssetReserveAfter,
        totalPositionSizeAfter,
        cumulativeNotionalAfter,
        openInterestNotionalAfter,
        totalLongPositionSize() - if (newPositionSize > 0) then abs(exchangedPositionSize) else 0,
        totalShortPositionSize() - if (newPositionSize < 0) then abs(exchangedPositionSize) else 0,
        openInterestLong() - if (newPositionSize > 0) then exchangedQuoteAssetAmount else 0,
        openInterestShort() - if (newPositionSize < 0) then exchangedQuoteAssetAmount else 0
      )
      ++
      withdraw(i.caller, feeToLiquidator)
      ++
      updateBalance(newAmmBalance)
    } else {
      # Liquidate position fully
      let (
        x1,
        badDebt,
        x2,
        x3,
        quoteAssetReserveAfter,
        baseAssetReserveAfter,
        totalPositionSizeAfter,
        cumulativeNotionalAfter,
        openInterestNotionalAfter,
        exchangedQuoteAssetAmount,
        totalLongAfter,
        totalShortAfter,
        totalLongOpenInterestAfter,
        totalShortOpenInterestAfter
      ) = internalClosePosition(_trader, false)
      
      # Liquidator get a certain (liquidationFeeRatio) percentage from a total position
      #
      let liquidationPenalty = muld(exchangedQuoteAssetAmount, liquidationFeeRatio())
      let feeToLiquidator = liquidationPenalty / 2
      let feeToInsurance = liquidationPenalty - feeToLiquidator

      # Liquidating a position can incur bad debt. If AMM does not have enough funds to cover up bad debt
      # use Insurance Fund to cover it up
      let ammBalance = cbalance() - liquidationPenalty
      let (newAmmBalance, x11) = if (ammBalance < 0) then {
        (0, abs(ammBalance))
      } else {
        (ammBalance, 0)
      }

      let (borrowed, assetId) = getBorrowedByTrader(_trader) 

      strict doLiquidateCollateral = if (borrowed > 0) then {
        strict realizeAndClose = invoke(
          collateralAddress(),
          "realizePartiallyAndClose",
          [_trader, assetId],
          [] # Full liquidation of remain collateral
        )
        []
      } else {
        []
      }

      # Move bad debt to locked TODO
      strict x = if (badDebt > 0) then {
        strict lockBadDebt = invoke(
          vaultAddress(),
          "exchangeFreeAndLocked",
          [badDebt],
          []
        )
        []
      } else {
        []
      }

      strict unstake = invoke(
        vaultAddress(),
        "withdrawLocked",
        [liquidationPenalty],
        []
      )

      strict depositInsurance = invoke(
        vaultAddress(),
        "addFree",
        [],
        [AttachedPayment(quoteAsset(), feeToInsurance)]
      )

      strict notifyNotional = invoke(
        minerAddress(),
        "notifyNotional",
        [_trader, 0],
        []
      )

      deletePosition(_trader)
      ++ 
      updateAmm(
        quoteAssetReserveAfter,
        baseAssetReserveAfter,
        totalPositionSizeAfter,
        cumulativeNotionalAfter,
        openInterestNotionalAfter,
        totalLongAfter,
        totalShortAfter,
        totalLongOpenInterestAfter,
        totalShortOpenInterestAfter
      )
      ++
      withdraw(i.caller, feeToLiquidator)
      ++
      updateBalance(newAmmBalance)
    }
  }
}

@Callable(i)
func payFunding() = {
  let fundingBlockTimestamp = nextFundingBlockTimestamp()
  if (
    lastBlock.timestamp < fundingBlockTimestamp
    || !initialized()
    || paused()
  ) then {
    throw("Invalid funding block timestamp: " + lastBlock.timestamp.toString() + " < " + fundingBlockTimestamp.toString())
  } else {
    let underlyingPrice = getOracleTwapPrice()
    let (shortPremiumFraction, longPremiumFraction) = getFunding()
    
    updateFunding(
      fundingBlockTimestamp + fundingPeriodSeconds(),
      latestLongCumulativePremiumFraction() + longPremiumFraction,
      latestShortCumulativePremiumFraction() + shortPremiumFraction,
      divd(longPremiumFraction, underlyingPrice),
      divd(shortPremiumFraction, underlyingPrice)
    )
  }
}

@Callable(i)  
func syncTerminalPriceToOracle() = {
  let (
    newQuoteAssetWeight,
    newBaseAssetWeight,
    marginToVault
  ) = getSyncTerminalPrice(getOracleTwapPrice())

  strict lockBadDebt = invoke(
    vaultAddress(),
    "exchangeFreeAndLocked",
    [marginToVault],
    []
  )

  updateAmmWeights(newQuoteAssetWeight, newBaseAssetWeight)
}

@Callable(i)
func v_get(_trader: String) = {
  strict sync = invoke(this, "syncTerminalPriceToOracle", [], [])
  let (x1, x2, x3, x4) = internalClosePosition(_trader, false)
  throw(s(x2) + s(x3) + s(x4) + s(getMarginRatio(_trader)))
}

@Callable(i)
func view_calcRemainMarginWithFundingPayment(_trader: String) = {
  strict sync = invoke(this, "syncTerminalPriceToOracle", [], [])
  let (
    positionSize,
    positionMargin,
    pon,
    positionLstUpdCPF
  ) = getPosition(_trader)
  let (positionNotional, unrealizedPnl) = getPositionNotionalAndUnrealizedPnl(_trader, PNL_OPTION_SPOT)
  let (remainMargin, badDebt, fundingPayment) = calcRemainMarginWithFundingPayment(
      positionSize,
      positionMargin,
      positionLstUpdCPF,
      unrealizedPnl
  )
  throw(
    s(remainMargin) 
    + s(fundingPayment) 
    + s(getMarginRatio(_trader))
    + s(unrealizedPnl)
    + s(badDebt)
    + s(positionNotional)
  )
}

@Callable(i)
func view_getPegAdjustCost(_price: Int) = {
  let result = getSyncTerminalPrice(_price)
  throw(result._3.toString())
}

@Callable(i)
func view_getTerminalAmmPrice() = {
  let (terminalQuoteAssetReserve, terminalBaseAssetReserve) = getTerminalAmmState()
  let price = divd(terminalQuoteAssetReserve.muld(qtAstW()), terminalBaseAssetReserve.muld(bsAstW()))
  throw(price.toString())
}

@Callable(i)
func view_getFunding() = {
  let underlyingPrice = getOracleTwapPrice()
  let (shortPremiumFraction, longPremiumFraction) = getFunding()
  let longFunding = divd(longPremiumFraction, underlyingPrice)
  let shortFunding = divd(shortPremiumFraction, underlyingPrice)
  throw(s(longFunding) + s(shortFunding) + s(getTwapSpotPrice()) + s(getOracleTwapPrice()))
}

@Callable(i)
func view_getBorrowedByTrader(_trader: String) = {
  let (borrowed, assetId) = getBorrowedByTrader(_trader)
  throw(s(borrowed) + assetId)
}

@Verifier(tx)
func verify() = sigVerify(tx.bodyBytes, tx.proofs[0], adminPublicKey())