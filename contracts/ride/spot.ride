# This is a vAMM + Exchange contract
#
{-# STDLIB_VERSION 6 #-}
{-# SCRIPT_TYPE ACCOUNT #-}
{-# CONTENT_TYPE DAPP #-}

##### Key constants #####

# Global initialization state
let k_initialized = "k_initialized"                       # If AMM was properly initialized
let k_paused = "k_paused"                                 # If all AMM operations are paused

# Exchange settings
let k_fee = "k_fee"                                       # Exchange fee. Default is 0.3%. 1/3 goes to stakers, 2/3 goes to vault

# Coordinator
let k_coordinatorAddress = "k_coordinatorAddress"         # Address of Coordinator (base contract that keeps references to all infrastructure)

# Own keys
let k_amm = "k_amm"
let k_vault = "k_vault"
let k_amm_data = "k_amm_data"
let k_asset_vault = "k_asset_vault"
let k_asset_amm = "k_asset_amm"

# Coordinator keys
let k_admin_address = "k_admin_address"           # Address of admin account

func toCompositeKey(_key: String, _address: String) = _key + "_" + _address

##### Coordinator data ##### 
func coordinator() = addressFromString(this.getStringValue(k_coordinatorAddress)).valueOrErrorMessage("Coordinator not set")
func adminAddress() = addressFromString(coordinator().getStringValue(k_admin_address))
func isAdmin(i: Invocation) = if (i.caller == adminAddress()) then unit else throw("Only the Admin itself can invoke this function")
func getAddressIfValid(address: String) = address.addressFromString().valueOrErrorMessage("Can't parse \"" + address + "\" as address").toString()

##### NFT Artifacts #####
let k_token_param = "k_token_param"
let k_token_type = "k_token_type"
let FEE_REDUCTION_TOKEN_TYPE = "fee_reduction"

##### Core constants #####

let DIR_LONG          = 1
let DIR_SHORT         = 2
let SECONDS           = 1000
let DECIMAL_NUMBERS   = 6
let DECIMAL_UNIT      = 1 * (10 * 10 * 10 * 10 * 10 * 10)
let MINUTES_IN_YEAR   = 525600 * DECIMAL_UNIT
let ONE_DAY           = 86400 * DECIMAL_UNIT
let PNL_OPTION_SPOT   = 1
let PNL_OPTION_ORACLE = 2
let FUNDING_ASYMMETRIC = 1
let FUNDING_SYMMETRIC  = 2

##### Helper functions #####

func s(_x: Int) = _x.toString() + ","

func divd(_x: Int, _y: Int) = fraction(_x, DECIMAL_UNIT, _y, HALFEVEN)
func muld(_x: Int, _y: Int) = fraction(_x, _y, DECIMAL_UNIT, HALFEVEN)

func bdivd(_x: BigInt, _y: BigInt) = fraction(_x, DECIMAL_UNIT.toBigInt(), _y, HALFEVEN)
func bmuld(_x: BigInt, _y: BigInt) = fraction(_x, _y, DECIMAL_UNIT.toBigInt(), HALFEVEN)

func abs(_x: Int) = if (_x > 0) then _x else -_x
func vmax(_x: Int, _y: Int) = if (_x >= _y) then _x else _y

##### Accessor functions #####
func int(k: String) = this.getInteger(k).valueOrErrorMessage("no value for " + k)
func intOr(k: String, def: Int) = this.getInteger(k).valueOrElse(def)
func strA(_address: Address, _key: String) = {
  let val = _address.getString(_key).valueOrErrorMessage("No value for key " + _key)
  val
}

func intA(_address: Address, _key: String) = {
  let val = _address.getInteger(_key).valueOrErrorMessage("No value for key " + _key)
  val
}

func fee() = int(k_fee)

func getMarket(_assetId: String) = addressFromString(
  this.getString(k_asset_amm.toCompositeKey(_assetId)).valueOrElse("No market for: " + _assetId)
).valueOrErrorMessage("Invalid market address for: " + _assetId)

func getVault(_assetId: String) = addressFromString(
  this.getString(k_asset_vault.toCompositeKey(_assetId)).valueOrElse("No vault for: " + _assetId)
).valueOrErrorMessage("Invalid vault address for: " + _assetId)

# Checks if AMM was properly initialized
#
func initialized() = this.getBoolean(k_initialized).valueOrElse(false)

##### Update functions #####
func updateSettings(
  _fee: Int
) = {
  [
    IntegerEntry(k_fee, _fee)
  ]
}

##### Callable functions #####

# Pauses the contract. During the pause, no actions can be taken except for unpausing the contract. 
# The purpose of pausing the contract may be to perform maintenance work or to immediately stop the market.
#
# @notice admin only
@Callable(i)
func pause() = {
  if (i.caller != adminAddress()) then {
    throw("Invalid pause params")
  } else {
    [
      BooleanEntry(k_paused, true)
    ]
  }
}

# Unpauses contract.
#
# @notice admin only
@Callable(i)
func unpause() = {
  if (i.caller != adminAddress()) then {
    throw("Invalid unpause params")
  } else {
    [
      BooleanEntry(k_paused, false)
    ]
  }
}

# Changes the settings of the contract.
#
# @param _initMarginRatio The initial margin ratio for the contract.
# @param _mmr The maintenance margin ratio for the contract.
# @param _liquidationFeeRatio The liquidation fee ratio for the contract.
# @param _fundingPeriod The funding period for the contract.
# @param _fee The fee for the contract.
# @param _spreadLimit The spread limit for the contract.
# @param _maxPriceImpact The maximum price impact for the contract.
# @param _partialLiquidationRatio The partial liquidation ratio for the contract.
# @param _maxPriceSpread The maximum oracle / market price spread for the contract.
# @param _feeToStakersPercent The fee to stakers percent for the contract.
# @param _maxOracleDelay The maximum oracle delay (blocks) for the contract.
# @param _rolloverFee The rollover fee for the contract.
# @param _fundingMode Symmetric or asymmetric funding.
#
# @notice admin only
@Callable(i)
func changeSettings(
  _fee: Int
) = {
  if (
    _fee <= 0
    || !initialized()
    || i.caller != adminAddress()
  ) then {
    throw("Invalid changeSettings params")
  } else {
    updateSettings(
      _fee
    )
  }
}

@Callable(i)
func addAmm(
  _ammAddress: String,
  _vaultAddress: String,
  _vaultAsset: String,
  _data: String
) = isAdmin(i).valueOrElse({
  strict ammAddress = getAddressIfValid(_ammAddress)
  strict vaultAddress = getAddressIfValid(_vaultAddress)

  [
    BooleanEntry(k_amm.toCompositeKey(_ammAddress), true),
    BooleanEntry(k_vault.toCompositeKey(_vaultAddress), true),
    StringEntry(k_asset_vault.toCompositeKey(_vaultAsset), _vaultAddress),
    StringEntry(k_asset_amm.toCompositeKey(_vaultAsset), _ammAddress),
    StringEntry(k_amm_data.toCompositeKey(_ammAddress), _data)
  ]
})

@Callable(i)
func removeAmm(
  _ammAddress: String
) = isAdmin(i).valueOrElse({
  [
    DeleteEntry(k_amm.toCompositeKey(_ammAddress))
  ]
})

@Callable(i)
func initialize(
  _coordinator: String,
  _fee: Int
) = {
  if (
    _fee <= 0
    || initialized()
    || i.caller != this
  ) then {
    throw("Invalid initialize parameters")
  } else {
    updateSettings( 
      _fee
    )
    ++
    [
      BooleanEntry(k_initialized, true),
      StringEntry(k_coordinatorAddress, addressFromStringValue(_coordinator).toString())
    ]
  }
}

@Callable(i)
func swap(
  _targetAsset: String,
  _minTargetAmount: Int
) = {
  let _amount = i.payments[0].amount
  let _assetId = i.payments[0].assetId

  let assetId = if (_assetId.isDefined()) then _assetId.value().toBase58String() else "WAVES"
  let sourceDecimals = if (_assetId.isDefined()) then assetInfo(_assetId.value()).value().decimals else 8
  let targetDecimals = if (_targetAsset == "WAVES") then 8 else assetInfo(fromBase58String(_targetAsset)).valueOrErrorMessage("Invalid asset: " + _targetAsset).decimals
  let sourceAmountInAmmDecimals = if (sourceDecimals == 8) then _amount / 100 else if (sourceDecimals == 6) then _amount else throw("Invalid decimals (source)")

  # 1. Find market for source asset
  let sellMarket = getMarket(assetId)

  # 2. Sell it for USD
  strict s1 = invoke(sellMarket, "swapToQuote", [sourceAmountInAmmDecimals, 0], [])
  let usdAmount = match (s1) {
    case t: Int => t
    case _ => throw("Invalid swapToQuote result")
  }

  # 3. Find market for target asset
  let buyMarket = getMarket(_targetAsset)

  # 4. Buy it for USD
  strict s2 = invoke(buyMarket, "swapToBase", [usdAmount, _minTargetAmount], [])
  let targetAmount = match (s2) {
    case t: Int => if (targetDecimals == 8) then t * 100 else if (targetDecimals == 6) then t else throw("Invalid decimals (target)")
    case _ => throw("Invalid swapToBase result")
  }

  # 5. Get the fee for source asset addition
  let vaultToAdd = getVault(assetId)

  strict s3 = invoke(vaultToAdd, "getFeeRate", [_amount], [])
  let addFee = match (s3) {
    case t: Int => t
    case _ => throw("Invalid getFeeRate (add) result")
  }

  # 6. Get the fee for target asset depletion
  let vaultToRemove = getVault(_targetAsset)

  strict s4 = invoke(vaultToRemove, "getFeeRate", [-targetAmount], [])
  let removeFee = match (s4) {
    case t: Int => t
    case _ => throw("Invalid getFeeRate (remove) result")
  }

  # 7. Compute the fee as max fee from both
  let feeRate = if (addFee > removeFee) then addFee else removeFee
  let adjFee = fee().muld(feeRate)
  let feeInTargetToken = muld(targetAmount, fee().muld(feeRate))

  # strict xxx = throw("feeRate=" + feeRate.toString() 
  #  + " adjFee=" + adjFee.toString() 
  #  + " feeInTargetToken=" + feeInTargetToken.toString() 
  #  + " targetAmount=" + targetAmount.toString()
  #)
  
  # 8. Withdraw full amount of tokens to withdraw and deposit full amount of tokens to deposit
  #
  strict doWithdraw = invoke(vaultToRemove, "borrow", [targetAmount], [])
  strict doDeposit  = invoke(vaultToAdd   , "repay" , []            , [i.payments[0]])

  # 9. Distribute fee to LP
  let targetAsset = if (_targetAsset == "WAVES") then unit else fromBase58String(_targetAsset)
  strict doCollectFee = invoke(vaultToRemove, "addFree", [], [
    AttachedPayment(targetAsset, feeInTargetToken)
  ])
  

  # 9. Distribute fee to TSN holders
  # TBD
  
  # 10. Finish swap
  #
  [
    ScriptTransfer(i.caller, (targetAmount - feeInTargetToken), targetAsset)
  ]
}

@Verifier(tx)
func verify() = { 
  let coordinatorStr = this.getString(k_coordinatorAddress)
  if (coordinatorStr.isDefined()) then {
    let admin = addressFromStringValue(coordinatorStr.value()).getString(k_admin_address)
    if (admin.isDefined()) then {
      admin.value().addressFromStringValue().getBoolean("status_" + this.toString() + "_" + tx.id.toBase58String() ).valueOrElse(false)
    } else { 
      # Admin is not defined in coordinator, set admin first
      throw("unable to verify: admin not set in coordinator")
    }
  } else {
    # Coordinator not set, use native verify
    sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)
  }
}